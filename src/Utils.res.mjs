// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as Js_math from "rescript/lib/es6/js_math.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Js_string from "rescript/lib/es6/js_string.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";

function last(arr) {
  return Belt_Array.get(arr, arr.length - 1 | 0);
}

function removeInPlace(arr, index) {
  return arr.splice(index, 1);
}

var $$Array = {
  last: last,
  removeInPlace: removeInPlace
};

function divideFloat(a, b) {
  return a / b;
}

var divideInt = Caml_int32.div;

function divideAsFloat(a, b) {
  return a / b;
}

function divideWithReminder(x, y) {
  var reminder = (x % y);
  return [
          Js_math.floor(x / y),
          reminder
        ];
}

function minMax(min, max) {
  return function (val) {
    if (Caml_obj.lessthan(val, min)) {
      return min;
    } else if (Caml_obj.greaterthan(val, max)) {
      return max;
    } else {
      return val;
    }
  };
}

var $$Math = {
  divideFloat: divideFloat,
  divideInt: divideInt,
  divideAsFloat: divideAsFloat,
  divideWithReminder: divideWithReminder,
  minMax: minMax
};

function unwrap(option) {
  if (option !== undefined) {
    return Caml_option.valFromOption(option);
  } else {
    return PervasivesU.failwith("expect option to contain value");
  }
}

function flatten(option) {
  if (option === undefined) {
    return ;
  }
  var val = Caml_option.valFromOption(option);
  if (val !== undefined) {
    return Caml_option.some(Caml_option.valFromOption(val));
  }
  
}

function unwrapOr(option, $$default) {
  if (option !== undefined) {
    return Caml_option.valFromOption(option);
  } else {
    return $$default;
  }
}

function some(val) {
  return Caml_option.some(val);
}

function zip(a, b) {
  if (a !== undefined && b !== undefined) {
    return [
            Caml_option.valFromOption(a),
            Caml_option.valFromOption(b)
          ];
  }
  
}

var $$Option = {
  unwrap: unwrap,
  flatten: flatten,
  unwrapOr: unwrapOr,
  some: some,
  zip: zip
};

function andReturn(a) {
  console.log(a);
  return a;
}

var Log = {
  andReturn: andReturn
};

function getFilename(path) {
  return Js_string.replaceByRe(/^.*[\\\/]/, "", path);
}

var Path = {
  getFilename: getFilename
};

function invert(a) {
  return !a;
}

function then(a) {
  if (a) {
    return Caml_option.some(undefined);
  }
  
}

var Bool = {
  invert: invert,
  then: then
};

function leftPad(n) {
  if (n > 9.49) {
    return n.toFixed(0);
  } else {
    return "0" + n.toFixed(0);
  }
}

function formatSeconds(seconds) {
  var match = divideWithReminder(seconds, 3600);
  var hours = match[0];
  var match$1 = divideWithReminder(match[1], 60);
  var seconds$1 = match$1[1];
  var minutes = match$1[0];
  if (hours > 1.0) {
    return leftPad(hours) + ":" + leftPad(minutes) + ":" + leftPad(seconds$1);
  } else {
    return leftPad(minutes) + ":" + leftPad(seconds$1);
  }
}

function formatFrame(frame, fps) {
  return formatSeconds(frame / fps);
}

var Duration = {
  leftPad: leftPad,
  formatSeconds: formatSeconds,
  formatFrame: formatFrame
};

function neverRerender(__x) {
  return React.memo(__x, (function (param, param$1) {
                return true;
              }));
}

export {
  $$Array ,
  $$Math ,
  $$Option ,
  Log ,
  Path ,
  Bool ,
  Duration ,
  neverRerender ,
}
/* react Not a pure module */
