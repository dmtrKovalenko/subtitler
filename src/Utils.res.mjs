// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as Js_math from "rescript/lib/es6/js_math.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Js_string from "rescript/lib/es6/js_string.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Float from "@rescript/core/src/Core__Float.res.mjs";
import * as PervasivesU from "rescript/lib/es6/pervasivesU.js";

function last(arr) {
  return Belt_Array.get(arr, arr.length - 1 | 0);
}

function removeInPlace(arr, index) {
  return arr.splice(index, 1);
}

function filterMapWithIndex(a, f) {
  var l = a.length;
  var r = new Array(l);
  var j = 0;
  for(var i = 0; i < l; ++i){
    var v = a[i];
    var v$1 = f(v, i);
    if (v$1 !== undefined) {
      r[j] = Caml_option.valFromOption(v$1);
      j = j + 1 | 0;
    }
    
  }
  r.length = j;
  return r;
}

var $$Array$1 = {
  last: last,
  removeInPlace: removeInPlace,
  filterMapWithIndex: filterMapWithIndex
};

function divideFloat(a, b) {
  return a / b;
}

var divideInt = Caml_int32.div;

function divideAsFloat(a, b) {
  return a / b;
}

function divideWithRemainder(x, y) {
  var reminder = (x % y);
  return [
          Js_math.floor(x / y),
          reminder
        ];
}

function minMax(min, max) {
  return function (val) {
    if (Caml_obj.lessthan(val, min)) {
      return min;
    } else if (Caml_obj.greaterthan(val, max)) {
      return max;
    } else {
      return val;
    }
  };
}

var $$Math = {
  divideFloat: divideFloat,
  divideInt: divideInt,
  divideAsFloat: divideAsFloat,
  divideWithRemainder: divideWithRemainder,
  minMax: minMax
};

function unwrap(option) {
  if (option !== undefined) {
    return Caml_option.valFromOption(option);
  } else {
    return PervasivesU.failwith("expect option to contain value");
  }
}

function flatten(option) {
  if (option === undefined) {
    return ;
  }
  var val = Caml_option.valFromOption(option);
  if (val !== undefined) {
    return Caml_option.some(Caml_option.valFromOption(val));
  }
  
}

function unwrapOr(option, $$default) {
  if (option !== undefined) {
    return Caml_option.valFromOption(option);
  } else {
    return $$default;
  }
}

function unwrapOrElse(option, elseFn) {
  if (option !== undefined) {
    return Caml_option.some(Caml_option.valFromOption(option));
  } else {
    return elseFn();
  }
}

function some(val) {
  return Caml_option.some(val);
}

function zip(a, b) {
  if (a !== undefined && b !== undefined) {
    return [
            Caml_option.valFromOption(a),
            Caml_option.valFromOption(b)
          ];
  }
  
}

var $$Option = {
  unwrap: unwrap,
  flatten: flatten,
  unwrapOr: unwrapOr,
  unwrapOrElse: unwrapOrElse,
  some: some,
  zip: zip
};

function logU(a) {
  console.log(a);
}

function logU2(a, b) {
  console.log(a, b);
}

function andReturn(a) {
  console.log(a);
  return a;
}

function andReturn2(a, b) {
  console.log(a, b);
  return a;
}

var Log = {
  logU: logU,
  logU2: logU2,
  andReturn: andReturn,
  andReturn2: andReturn2
};

function getFilename(path) {
  return Js_string.replaceByRe(/^.*[\\\/]/, "", path);
}

var Path = {
  getFilename: getFilename
};

function invert(a) {
  return !a;
}

function then(a) {
  if (a) {
    return Caml_option.some(undefined);
  }
  
}

var Bool = {
  invert: invert,
  then: then
};

function leftPad(n) {
  if (n > 9.49) {
    return n.toFixed(0);
  } else {
    return "0" + n.toFixed(0);
  }
}

function formatSeconds(seconds) {
  var match = divideWithRemainder(seconds, 3600);
  var hours = match[0];
  var match$1 = divideWithRemainder(match[1], 60);
  var seconds$1 = match$1[1];
  var minutes = match$1[0];
  if (hours > 1.0) {
    return leftPad(hours) + ":" + leftPad(minutes) + ":" + leftPad(seconds$1);
  } else {
    return leftPad(minutes) + ":" + leftPad(seconds$1);
  }
}

function formatMillis(timestamp) {
  var match = divideWithRemainder(timestamp, 60);
  var rawSeconds = match[1];
  var seconds = Math.floor(rawSeconds);
  var millis = (rawSeconds - seconds) * 1000;
  return match[0].toString().padStart(2, "0") + ":" + seconds.toFixed(0).padStart(2, "0") + "," + millis.toFixed(0).padStart(3, "0");
}

function parseMillisInputToSecondsTimestampString(timestamp) {
  var minutesString = timestamp.slice(0, 2);
  var secondsString = timestamp.slice(3, 5);
  var millisString = timestamp.slice(6, 9);
  var match = Core__Float.fromString(minutesString);
  var match$1 = Core__Float.fromString(secondsString);
  var match$2 = Core__Float.fromString(millisString);
  if (match === undefined) {
    return {
            TAG: "Error",
            _0: "Invalid timestamp format"
          };
  }
  if (match$1 === undefined) {
    return {
            TAG: "Error",
            _0: "Invalid timestamp format"
          };
  }
  if (match$2 === undefined) {
    return {
            TAG: "Error",
            _0: "Invalid timestamp format"
          };
  }
  var totalSeconds = match * 60 + match$1 + match$2 / 1000;
  return {
          TAG: "Ok",
          _0: totalSeconds
        };
}

function parseMillisInputToSeconds(inputStr) {
  if (inputStr.length !== 9) {
    return {
            TAG: "Error",
            _0: "Input string is not completed"
          };
  } else {
    return parseMillisInputToSecondsTimestampString(inputStr);
  }
}

function formatFrame(frame, fps) {
  return formatSeconds(frame / fps);
}

var Duration = {
  leftPad: leftPad,
  formatSeconds: formatSeconds,
  formatMillis: formatMillis,
  parseMillisInputToSecondsTimestampString: parseMillisInputToSecondsTimestampString,
  parseMillisInputToSeconds: parseMillisInputToSeconds,
  formatFrame: formatFrame
};

function neverRerender(__x) {
  return React.memo(__x, (function (param, param$1) {
                return true;
              }));
}

export {
  $$Array$1 as $$Array,
  $$Math ,
  $$Option ,
  Log ,
  Path ,
  Bool ,
  Duration ,
  neverRerender ,
}
/* react Not a pure module */
