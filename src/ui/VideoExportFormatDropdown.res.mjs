// Generated by ReScript, PLEASE EDIT WITH CARE

import * as React from "react";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as DropdownMenu from "./DropdownMenu.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";
import * as UseSupportedCodecs from "./UseSupportedCodecs.res.mjs";
import * as Outline from "@heroicons/react/24/outline";

function videoCodecFromString(str) {
  switch (str) {
    case "av1" :
        return "AV1";
    case "avc" :
        return "AVC";
    case "hevc" :
        return "HEVC";
    case "vp8" :
        return "VP8";
    case "vp9" :
        return "VP9";
    default:
      return ;
  }
}

function audioCodecFromString(str) {
  switch (str) {
    case "aac" :
        return "AAC";
    case "flac" :
        return "FLAC";
    case "mp3" :
        return "MP3";
    case "opus" :
        return "Opus";
    case "vorbis" :
        return "Vorbis";
    default:
      return ;
  }
}

var videoCodecs = [
  {
    codec: "AVC",
    id: "avc",
    label: "H.264 (AVC)",
    description: "Best compatibility"
  },
  {
    codec: "HEVC",
    id: "hevc",
    label: "H.265 (HEVC)",
    description: "Better compression"
  },
  {
    codec: "VP9",
    id: "vp9",
    label: "VP9",
    description: "Open standard"
  },
  {
    codec: "VP8",
    id: "vp8",
    label: "VP8",
    description: "Legacy WebM"
  },
  {
    codec: "AV1",
    id: "av1",
    label: "AV1",
    description: "Best compression"
  }
];

var audioCodecs = [
  {
    codec: "AAC",
    id: "aac",
    label: "AAC",
    description: "Best compatibility"
  },
  {
    codec: "Opus",
    id: "opus",
    label: "Opus",
    description: "Best quality"
  },
  {
    codec: "MP3",
    id: "mp3",
    label: "MP3",
    description: "Universal"
  },
  {
    codec: "Vorbis",
    id: "vorbis",
    label: "Vorbis",
    description: "Open standard"
  },
  {
    codec: "FLAC",
    id: "flac",
    label: "FLAC",
    description: "Lossless"
  }
];

var formats = [
  {
    format: "MP4",
    label: "MP4",
    extension: ".mp4",
    mimeType: "video/mp4",
    description: "Best compatibility",
    supportedVideoCodecs: [
      "AVC",
      "HEVC",
      "VP9",
      "VP8",
      "AV1"
    ],
    supportedAudioCodecs: [
      "AAC",
      "Opus",
      "MP3",
      "Vorbis",
      "FLAC"
    ]
  },
  {
    format: "WebM",
    label: "WebM",
    extension: ".webm",
    mimeType: "video/webm",
    description: "Smaller file size",
    supportedVideoCodecs: [
      "VP9",
      "VP8",
      "AV1"
    ],
    supportedAudioCodecs: [
      "Opus",
      "Vorbis"
    ]
  },
  {
    format: "MOV",
    label: "MOV",
    extension: ".mov",
    mimeType: "video/quicktime",
    description: "Apple devices",
    supportedVideoCodecs: [
      "AVC",
      "HEVC",
      "VP9",
      "VP8",
      "AV1"
    ],
    supportedAudioCodecs: [
      "AAC",
      "Opus",
      "MP3",
      "Vorbis",
      "FLAC"
    ]
  }
];

function formatToString(format) {
  switch (format) {
    case "MP4" :
        return "mp4";
    case "WebM" :
        return "webm";
    case "MOV" :
        return "mov";
    
  }
}

function videoCodecToString(codec) {
  switch (codec) {
    case "AVC" :
        return "avc";
    case "HEVC" :
        return "hevc";
    case "VP9" :
        return "vp9";
    case "VP8" :
        return "vp8";
    case "AV1" :
        return "av1";
    
  }
}

function audioCodecToString(codec) {
  switch (codec) {
    case "AAC" :
        return "aac";
    case "Opus" :
        return "opus";
    case "MP3" :
        return "mp3";
    case "Vorbis" :
        return "vorbis";
    case "FLAC" :
        return "flac";
    
  }
}

function formatToLabel(format) {
  return Core__Option.getOr(Core__Option.map(formats.find(function (f) {
                      return f.format === format;
                    }), (function (f) {
                    return f.label;
                  })), "Unknown");
}

function videoCodecToLabel(codec) {
  return Core__Option.getOr(Core__Option.map(videoCodecs.find(function (c) {
                      return c.codec === codec;
                    }), (function (c) {
                    return c.label;
                  })), "Unknown");
}

function audioCodecToLabel(codec) {
  return Core__Option.getOr(Core__Option.map(audioCodecs.find(function (c) {
                      return c.codec === codec;
                    }), (function (c) {
                    return c.label;
                  })), "Unknown");
}

function getFormatInfo(format) {
  return formats.find(function (f) {
              return f.format === format;
            });
}

function getDefaultVideoCodec(format) {
  switch (format) {
    case "WebM" :
        return "VP9";
    case "MP4" :
    case "MOV" :
        return "AVC";
    
  }
}

function getDefaultAudioCodec(format) {
  switch (format) {
    case "WebM" :
        return "Opus";
    case "MP4" :
    case "MOV" :
        return "AAC";
    
  }
}

function getSupportedVideoCodecs(format) {
  return Core__Option.getOr(Core__Option.map(formats.find(function (f) {
                      return f.format === format;
                    }), (function (f) {
                    return f.supportedVideoCodecs;
                  })), []);
}

function getSupportedAudioCodecs(format) {
  return Core__Option.getOr(Core__Option.map(formats.find(function (f) {
                      return f.format === format;
                    }), (function (f) {
                    return f.supportedAudioCodecs;
                  })), []);
}

function makeDefaultSettings() {
  return {
          format: "MP4",
          videoCodec: "AVC",
          audioCodec: "AAC"
        };
}

function settingsToLabel(settings) {
  var formatLabel = formatToLabel(settings.format);
  var videoLabel = videoCodecToLabel(settings.videoCodec);
  return formatLabel + " / " + videoLabel;
}

function VideoExportFormatDropdown$FormatSelector(props) {
  var onFormatChange = props.onFormatChange;
  var selectedFormat = props.selectedFormat;
  return JsxRuntime.jsxs("div", {
              children: [
                JsxRuntime.jsx(DropdownMenu.Label.make, {
                      children: "Container",
                      className: "text-xs text-gray-400"
                    }),
                JsxRuntime.jsx(DropdownMenu.RadioGroup.make, {
                      children: formats.map(function (formatInfo) {
                            return JsxRuntime.jsx(DropdownMenu.RadioItem.make, {
                                        children: JsxRuntime.jsxs("span", {
                                              children: [
                                                JsxRuntime.jsxs("span", {
                                                      children: [
                                                        selectedFormat === formatInfo.format ? JsxRuntime.jsx(Outline.CheckIcon, {
                                                                className: "mr-2 h-4 w-4 text-orange-400"
                                                              }) : JsxRuntime.jsx("span", {
                                                                className: "mr-2 h-4 w-4"
                                                              }),
                                                        formatInfo.label
                                                      ],
                                                      className: "flex items-center"
                                                    }),
                                                JsxRuntime.jsx("span", {
                                                      children: formatInfo.description,
                                                      className: "text-xs text-gray-400 ml-4"
                                                    })
                                              ],
                                              className: "flex items-center justify-between w-full"
                                            }),
                                        value: formatToString(formatInfo.format)
                                      }, formatInfo.extension);
                          }),
                      value: formatToString(selectedFormat),
                      onValueChange: (function (value) {
                          switch (value) {
                            case "mov" :
                                return onFormatChange("MOV");
                            case "mp4" :
                                return onFormatChange("MP4");
                            case "webm" :
                                return onFormatChange("WebM");
                            default:
                              return ;
                          }
                        })
                    })
              ],
              className: "space-y-1"
            });
}

var FormatSelector = {
  make: VideoExportFormatDropdown$FormatSelector
};

function VideoExportFormatDropdown$VideoCodecSelector(props) {
  var browserSupportedCodecs = props.browserSupportedCodecs;
  var onCodecChange = props.onCodecChange;
  var selectedCodec = props.selectedCodec;
  var formatSupportedCodecs = getSupportedVideoCodecs(props.selectedFormat);
  var availableCodecs = videoCodecs.filter(function (c) {
        if (formatSupportedCodecs.includes(c.codec)) {
          return browserSupportedCodecs.includes(c.id);
        } else {
          return false;
        }
      });
  return JsxRuntime.jsxs("div", {
              children: [
                JsxRuntime.jsx(DropdownMenu.Label.make, {
                      children: "Video Codec",
                      className: "text-xs text-gray-400"
                    }),
                availableCodecs.length === 0 ? JsxRuntime.jsx("div", {
                        children: "No supported codecs found",
                        className: "px-2 py-1 text-xs text-gray-500 italic"
                      }) : JsxRuntime.jsx(DropdownMenu.RadioGroup.make, {
                        children: availableCodecs.map(function (codecInfo) {
                              return JsxRuntime.jsx(DropdownMenu.RadioItem.make, {
                                          children: JsxRuntime.jsxs("span", {
                                                children: [
                                                  JsxRuntime.jsxs("span", {
                                                        children: [
                                                          selectedCodec === codecInfo.codec ? JsxRuntime.jsx(Outline.CheckIcon, {
                                                                  className: "mr-2 h-4 w-4 text-orange-400"
                                                                }) : JsxRuntime.jsx("span", {
                                                                  className: "mr-2 h-4 w-4"
                                                                }),
                                                          codecInfo.label
                                                        ],
                                                        className: "flex items-center"
                                                      }),
                                                  JsxRuntime.jsx("span", {
                                                        children: codecInfo.description,
                                                        className: "text-xs text-gray-400 ml-4"
                                                      })
                                                ],
                                                className: "flex items-center justify-between w-full"
                                              }),
                                          value: codecInfo.id
                                        }, codecInfo.id);
                            }),
                        value: videoCodecToString(selectedCodec),
                        onValueChange: (function (value) {
                            Core__Option.forEach(videoCodecFromString(value), onCodecChange);
                          })
                      })
              ],
              className: "space-y-1"
            });
}

var VideoCodecSelector = {
  make: VideoExportFormatDropdown$VideoCodecSelector
};

function VideoExportFormatDropdown$AudioCodecSelector(props) {
  var browserSupportedCodecs = props.browserSupportedCodecs;
  var onCodecChange = props.onCodecChange;
  var selectedCodec = props.selectedCodec;
  var formatSupportedCodecs = getSupportedAudioCodecs(props.selectedFormat);
  var availableCodecs = audioCodecs.filter(function (c) {
        if (formatSupportedCodecs.includes(c.codec)) {
          return browserSupportedCodecs.includes(c.id);
        } else {
          return false;
        }
      });
  return JsxRuntime.jsxs("div", {
              children: [
                JsxRuntime.jsx(DropdownMenu.Label.make, {
                      children: "Audio Codec",
                      className: "text-xs text-gray-400"
                    }),
                availableCodecs.length === 0 ? JsxRuntime.jsx("div", {
                        children: "No supported codecs found",
                        className: "px-2 py-1 text-xs text-gray-500 italic"
                      }) : JsxRuntime.jsx(DropdownMenu.RadioGroup.make, {
                        children: availableCodecs.map(function (codecInfo) {
                              return JsxRuntime.jsx(DropdownMenu.RadioItem.make, {
                                          children: JsxRuntime.jsxs("span", {
                                                children: [
                                                  JsxRuntime.jsxs("span", {
                                                        children: [
                                                          selectedCodec === codecInfo.codec ? JsxRuntime.jsx(Outline.CheckIcon, {
                                                                  className: "mr-2 h-4 w-4 text-orange-400"
                                                                }) : JsxRuntime.jsx("span", {
                                                                  className: "mr-2 h-4 w-4"
                                                                }),
                                                          codecInfo.label
                                                        ],
                                                        className: "flex items-center"
                                                      }),
                                                  JsxRuntime.jsx("span", {
                                                        children: codecInfo.description,
                                                        className: "text-xs text-gray-400 ml-4"
                                                      })
                                                ],
                                                className: "flex items-center justify-between w-full"
                                              }),
                                          value: codecInfo.id
                                        }, codecInfo.id);
                            }),
                        value: audioCodecToString(selectedCodec),
                        onValueChange: (function (value) {
                            Core__Option.forEach(audioCodecFromString(value), onCodecChange);
                          })
                      })
              ],
              className: "space-y-1"
            });
}

var AudioCodecSelector = {
  make: VideoExportFormatDropdown$AudioCodecSelector
};

function VideoExportFormatDropdown(props) {
  var onRender = props.onRender;
  var onSettingsChange = props.onSettingsChange;
  var settings = props.settings;
  var supportedCodecs = UseSupportedCodecs.useSupportedCodecs(undefined, undefined, undefined);
  var match = React.useState(function () {
        return false;
      });
  var setIsOpen = match[1];
  var handleFormatChange = function (format) {
    var formatVideoCodecs = getSupportedVideoCodecs(format);
    var formatAudioCodecs = getSupportedAudioCodecs(format);
    var newVideoCodec;
    if (formatVideoCodecs.includes(settings.videoCodec) && supportedCodecs.videoCodecs.includes(videoCodecToString(settings.videoCodec))) {
      newVideoCodec = settings.videoCodec;
    } else {
      var firstSupported = formatVideoCodecs.find(function (c) {
            return supportedCodecs.videoCodecs.includes(videoCodecToString(c));
          });
      newVideoCodec = Core__Option.getOr(firstSupported, getDefaultVideoCodec(format));
    }
    var newAudioCodec;
    if (formatAudioCodecs.includes(settings.audioCodec) && supportedCodecs.audioCodecs.includes(audioCodecToString(settings.audioCodec))) {
      newAudioCodec = settings.audioCodec;
    } else {
      var firstSupported$1 = formatAudioCodecs.find(function (c) {
            return supportedCodecs.audioCodecs.includes(audioCodecToString(c));
          });
      newAudioCodec = Core__Option.getOr(firstSupported$1, getDefaultAudioCodec(format));
    }
    onSettingsChange({
          format: format,
          videoCodec: newVideoCodec,
          audioCodec: newAudioCodec
        });
  };
  var handleVideoCodecChange = function (videoCodec) {
    onSettingsChange({
          format: settings.format,
          videoCodec: videoCodec,
          audioCodec: settings.audioCodec
        });
  };
  var handleAudioCodecChange = function (audioCodec) {
    onSettingsChange({
          format: settings.format,
          videoCodec: settings.videoCodec,
          audioCodec: audioCodec
        });
  };
  var handleRenderClick = function () {
    setIsOpen(function (param) {
          return false;
        });
    onRender();
  };
  return JsxRuntime.jsxs(DropdownMenu.Root.make, {
              children: [
                JsxRuntime.jsx(DropdownMenu.Trigger.make, {
                      children: props.children,
                      asChild: true
                    }),
                JsxRuntime.jsxs(DropdownMenu.Content.make, {
                      children: [
                        JsxRuntime.jsx(DropdownMenu.Label.make, {
                              children: "Export Video",
                              className: "text-xl"
                            }),
                        JsxRuntime.jsx(DropdownMenu.Label.make, {
                              children: "This will render subtitled video locally using your browser and save it on the disc. Codecs and containers support here is managed by your browser.",
                              className: "text-sm text-gray-400 -mt-1.5 !font-normal"
                            }),
                        supportedCodecs.loading ? JsxRuntime.jsx("div", {
                                children: "Detecting supported codecs...",
                                className: "px-2 py-1 text-xs text-gray-400"
                              }) : null,
                        JsxRuntime.jsx(DropdownMenu.Separator.make, {}),
                        JsxRuntime.jsx(VideoExportFormatDropdown$FormatSelector, {
                              selectedFormat: settings.format,
                              onFormatChange: handleFormatChange
                            }),
                        JsxRuntime.jsx(DropdownMenu.Separator.make, {}),
                        JsxRuntime.jsx(VideoExportFormatDropdown$VideoCodecSelector, {
                              selectedFormat: settings.format,
                              selectedCodec: settings.videoCodec,
                              onCodecChange: handleVideoCodecChange,
                              browserSupportedCodecs: supportedCodecs.videoCodecs
                            }),
                        JsxRuntime.jsx(DropdownMenu.Separator.make, {}),
                        JsxRuntime.jsx(VideoExportFormatDropdown$AudioCodecSelector, {
                              selectedFormat: settings.format,
                              selectedCodec: settings.audioCodec,
                              onCodecChange: handleAudioCodecChange,
                              browserSupportedCodecs: supportedCodecs.audioCodecs
                            }),
                        JsxRuntime.jsx(DropdownMenu.Separator.make, {}),
                        JsxRuntime.jsx("div", {
                              children: JsxRuntime.jsxs("button", {
                                    children: [
                                      JsxRuntime.jsx(Outline.SparklesIcon, {
                                            className: "size-5"
                                          }),
                                      "RENDER & DOWNLOAD"
                                    ],
                                    className: "w-full flex items-center justify-center gap-2 px-4 py-2.5 rounded-lg font-medium text-white bg-gradient-to-r from-orange-500 to-amber-500 hover:from-orange-400 hover:to-amber-400 transition-all shadow-lg shadow-orange-500/20 active:scale-[0.98] disabled:opacity-50 disabled:cursor-not-allowed",
                                    disabled: supportedCodecs.loading,
                                    onClick: (function (param) {
                                        handleRenderClick();
                                      })
                                  }),
                              className: "p-2"
                            })
                      ],
                      className: "w-80",
                      sideOffset: props.sideOffset,
                      align: props.align
                    })
              ],
              open_: match[0],
              onOpenChange: (function (isOpenValue) {
                  setIsOpen(function (param) {
                        return isOpenValue;
                      });
                })
            });
}

var make = VideoExportFormatDropdown;

export {
  videoCodecFromString ,
  audioCodecFromString ,
  videoCodecs ,
  audioCodecs ,
  formats ,
  formatToString ,
  videoCodecToString ,
  audioCodecToString ,
  formatToLabel ,
  videoCodecToLabel ,
  audioCodecToLabel ,
  getFormatInfo ,
  getDefaultVideoCodec ,
  getDefaultAudioCodec ,
  getSupportedVideoCodecs ,
  getSupportedAudioCodecs ,
  makeDefaultSettings ,
  settingsToLabel ,
  FormatSelector ,
  VideoCodecSelector ,
  AudioCodecSelector ,
  make ,
}
/* react Not a pure module */
