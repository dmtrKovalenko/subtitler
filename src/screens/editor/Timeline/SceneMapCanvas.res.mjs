// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "../../../Utils.res.mjs";
import * as React from "react";
import * as Js_math from "rescript/lib/es6/js_math.js";
import * as Belt_Range from "rescript/lib/es6/belt_Range.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as CanvasSize from "./canvasSize.res.mjs";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as EditorContext from "../EditorContext.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";

function renderRoundedRect(ctx, x, y, width, height, radius, param) {
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.arcTo(x + width, y, x + width, y + height, radius);
  ctx.arcTo(x + width, y + height, x, y + height, radius);
  ctx.arcTo(x, y + height, x, y, radius);
  ctx.arcTo(x, y, x + width, y, radius);
  ctx.stroke();
}

function clipOverTimeLineElement(ctx, y, width, fill) {
  renderRoundedRect(ctx, 32, y, width, 120, 12.0, undefined);
  ctx.clip();
  ctx.fillStyle = fill;
  ctx.fillRect(32, y, width, 120);
}

function renderMainScene(ctx, size, editorContext) {
  var aspectRatio = editorContext.videoMeta.width / editorContext.videoMeta.height;
  var width = Math.floor(120 * aspectRatio);
  clipOverTimeLineElement(ctx, 64, size.maxSceneWidth, "#000");
  var maxFramesInScene = Caml_int32.div(size.maxSceneWidth | 0, width);
  var framesBreak = Caml_int32.div(editorContext.videoMeta.duration | 0, maxFramesInScene);
  var i = {
    contents: 0
  };
  var seekAndRender = function () {
    editorContext.seekUnsafe(Math.imul(framesBreak, i.contents), (function () {
            editorContext.renderFrame(ctx, 32 + Math.imul(i.contents, width) | 0, 64, width, 120);
            if (i.contents < maxFramesInScene) {
              i.contents = i.contents + 1 | 0;
              return seekAndRender();
            }
            
          }));
  };
  seekAndRender();
}

function renderAudioWaveForm(ctx, endFrame, startFrame, x0, y0, audioSpaceWidth, audioName, editorContext) {
  
}

function renderAudioMap(ctx, size, editorContext) {
  
}

function renderTimeSlots(ctx, size, editorContext) {
  var stepsCount = Js_math.floor(Utils.$$Math.divideFloat(size.maxSceneWidth, 100));
  Caml_int32.div(editorContext.videoMeta.duration | 0, stepsCount);
  Belt_Range.forEach(0, stepsCount, (function (i) {
          var x = Math.imul(i, 100) + 32 | 0;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, 18);
          ctx.strokeStyle = "#475569";
          ctx.stroke();
          if (i % 2 === 0) {
            ctx.font = "12px sans-serif";
            ctx.fillStyle = "#64748b";
            return ;
          }
          
        }));
}

function SceneMapCanvas(props) {
  var size = props.size;
  var canvasRef = React.useRef(null);
  var editorContext = EditorContext.useEditorContext();
  CanvasSize.useCanvasScale(canvasRef, size);
  React.useEffect((function () {
          Belt_Option.map(Caml_option.nullable_to_opt(canvasRef.current), (function (element) {
                  var ctx = element.getContext("2d");
                  renderTimeSlots(ctx, size, editorContext);
                  ctx.save();
                  ctx.restore();
                  renderMainScene(ctx, size, editorContext);
                }));
        }), [size]);
  return JsxRuntime.jsx("canvas", {
              ref: Caml_option.some(canvasRef),
              className: "absolute inset-0",
              style: {
                height: String(size.height) + "px",
                width: String(size.width) + "px"
              },
              height: String(Js_math.floor(size.scaledHeight)) + "px",
              width: String(Js_math.floor(size.scaledWidth)) + "px"
            });
}

var Canvas;

var Canvas2d;

var make = SceneMapCanvas;

export {
  Canvas ,
  Canvas2d ,
  renderRoundedRect ,
  clipOverTimeLineElement ,
  renderMainScene ,
  renderAudioWaveForm ,
  renderAudioMap ,
  renderTimeSlots ,
  make ,
}
/* Utils Not a pure module */
