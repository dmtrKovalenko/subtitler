// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "rescript/lib/es6/caml.js";
import * as React from "react";
import * as Slider from "../../../ui/Slider.res.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as ChunkEditor from "./ChunkEditor.res.mjs";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as EditorContext from "../EditorContext.res.mjs";
import * as WordTimestamps from "../WordTimestamps.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";

function subtitleCueToWordChunk(cue) {
  return {
          text: cue.text,
          timestamp: cue.timestamp
        };
}

function detectPauseIndices(wordChunks) {
  var pauseIndices = [];
  wordChunks.forEach(function (chunk, i) {
        var nextChunk = wordChunks[i + 1 | 0];
        if (nextChunk === undefined) {
          return ;
        }
        var thisEnd = Core__Option.getOr(Caml_option.nullable_to_opt(chunk.timestamp[1]), chunk.timestamp[0]);
        var nextStart = nextChunk.timestamp[0];
        if (nextStart - thisEnd > 0.2) {
          pauseIndices.push(i);
          return ;
        }
        
      });
  return pauseIndices;
}

function groupByPauses(wordCount, pauseAfterIndices) {
  if (wordCount === 0) {
    return [];
  }
  var groups = [];
  var currentStart = {
    contents: 0
  };
  pauseAfterIndices.forEach(function (pauseAfterIdx) {
        if (pauseAfterIdx >= currentStart.contents && pauseAfterIdx < wordCount) {
          groups.push([
                currentStart.contents,
                pauseAfterIdx
              ]);
          currentStart.contents = pauseAfterIdx + 1 | 0;
          return ;
        }
        
      });
  if (currentStart.contents < wordCount) {
    groups.push([
          currentStart.contents,
          wordCount - 1 | 0
        ]);
  }
  return groups;
}

function resizeGroupsToRanges(wordChunks, groups, maxSize) {
  return groups.flatMap(function (param) {
              var groupEnd = param[1];
              var groupStart = param[0];
              var groupWords = wordChunks.slice(groupStart, groupEnd + 1 | 0);
              var totalLength = Core__Array.reduce(groupWords, 0, (function (acc, w) {
                      return acc + w.text.trim().length | 0;
                    }));
              if (!(totalLength > maxSize && groupWords.length > 1)) {
                return [[
                          groupStart,
                          groupEnd
                        ]];
              }
              var relation = totalLength / maxSize;
              var subChunkSize = Math.ceil(groupWords.length / relation) | 0;
              var ranges = [];
              var numSubChunks = Math.ceil(groupWords.length / subChunkSize) | 0;
              for(var i = 0; i < numSubChunks; ++i){
                var localStart = Math.imul(i, subChunkSize);
                var localEnd = Caml.int_min(Math.imul(i + 1 | 0, subChunkSize) - 1 | 0, groupWords.length - 1 | 0);
                if (localStart <= localEnd) {
                  ranges.push([
                        groupStart + localStart | 0,
                        groupStart + localEnd | 0
                      ]);
                }
                
              }
              return ranges;
            });
}

function calculateCueRanges(wordChunks, pauseAfterIndices, size) {
  var groups = groupByPauses(wordChunks.length, pauseAfterIndices);
  return resizeGroupsToRanges(wordChunks, groups, size);
}

function buildCueFromRange(wordChunks, startIdx, endIdx) {
  var words = wordChunks.slice(startIdx, endIdx + 1 | 0);
  var firstWord = words[0];
  var lastWord = words[words.length - 1 | 0];
  var combinedText = words.map(function (w) {
            return w.text.trim();
          }).filter(function (s) {
          return s !== "";
        }).join(" ");
  return {
          id: Math.random(),
          text: combinedText,
          isInProgress: undefined,
          timestamp: [
            WordTimestamps.start(firstWord),
            WordTimestamps.end_(lastWord)
          ]
        };
}

function buildCuesFromRanges(wordChunks, cueRanges) {
  return cueRanges.map(function (param) {
              return buildCueFromRange(wordChunks, param[0], param[1]);
            });
}

function updatePauseIndicesAfterEdit(pauseAfterIndices, editedCueStart, editedCueEnd, oldWordCount, newWordCount) {
  var delta = newWordCount - oldWordCount | 0;
  if (delta === 0) {
    return pauseAfterIndices;
  } else {
    return Core__Array.filterMap(pauseAfterIndices, (function (idx) {
                  if (idx < editedCueStart) {
                    return idx;
                  }
                  if (!(idx >= editedCueStart && idx <= editedCueEnd)) {
                    return idx + delta | 0;
                  }
                  if (newWordCount === 0) {
                    return ;
                  }
                  var relativePos = (idx - editedCueStart | 0) / oldWordCount;
                  var newIdx = editedCueStart + (relativePos * newWordCount | 0) | 0;
                  if (newIdx < ((editedCueStart + newWordCount | 0) - 1 | 0)) {
                    return newIdx;
                  }
                  
                }));
  }
}

function updateRangesAfterEdit(cueRanges, editedCueIndex, oldWordCount, newWordCount) {
  var delta = newWordCount - oldWordCount | 0;
  if (delta === 0) {
    return cueRanges;
  } else {
    return cueRanges.map(function (range, i) {
                var startIdx = range[0];
                if (i === editedCueIndex) {
                  return [
                          startIdx,
                          (startIdx + newWordCount | 0) - 1 | 0
                        ];
                } else if (i > editedCueIndex) {
                  return [
                          startIdx + delta | 0,
                          range[1] + delta | 0
                        ];
                } else {
                  return range;
                }
              });
  }
}

function useChunksState(subtitles, transcriptionInProgress, default_chunk_size) {
  var subtitlesRef = React.useRef(subtitles);
  var match = React.useState(function () {
        return "TranscriptionInProgress";
      });
  var setTranscriptionState = match[1];
  var transcriptionState = match[0];
  if (!transcriptionInProgress && typeof transcriptionState !== "object" && subtitles.length > 0) {
    var wordChunks = subtitles.map(subtitleCueToWordChunk);
    var pauseAfterIndices = detectPauseIndices(wordChunks);
    var cueRanges = calculateCueRanges(wordChunks, pauseAfterIndices, default_chunk_size);
    setTranscriptionState(function (param) {
          return {
                  TAG: "SubtitlesReady",
                  wordChunks: wordChunks,
                  pauseAfterIndices: pauseAfterIndices,
                  cueRanges: cueRanges,
                  size: default_chunk_size
                };
        });
  }
  var activeSubtitles;
  activeSubtitles = typeof transcriptionState !== "object" ? subtitles : buildCuesFromRanges(transcriptionState.wordChunks, transcriptionState.cueRanges);
  subtitlesRef.current = activeSubtitles;
  return React.useMemo((function () {
                return {
                        activeSubtitles: activeSubtitles,
                        transcriptionState: transcriptionState,
                        subtitlesRef: subtitlesRef,
                        resizeSubtitles: (function (newSize) {
                            if (typeof transcriptionState !== "object") {
                              return ;
                            }
                            var pauseAfterIndices = transcriptionState.pauseAfterIndices;
                            var wordChunks = transcriptionState.wordChunks;
                            var newCueRanges = calculateCueRanges(wordChunks, pauseAfterIndices, newSize);
                            setTranscriptionState(function (param) {
                                  return {
                                          TAG: "SubtitlesReady",
                                          wordChunks: wordChunks,
                                          pauseAfterIndices: pauseAfterIndices,
                                          cueRanges: newCueRanges,
                                          size: newSize
                                        };
                                });
                          }),
                        removeChunk: (function (index, param) {
                            if (typeof transcriptionState !== "object") {
                              return ;
                            }
                            var size = transcriptionState.size;
                            var cueRanges = transcriptionState.cueRanges;
                            var match = cueRanges[index];
                            if (match === undefined) {
                              return ;
                            }
                            var endIdx = match[1];
                            var startIdx = match[0];
                            var removedWordCount = (endIdx - startIdx | 0) + 1 | 0;
                            var newWordChunks = transcriptionState.wordChunks.filter(function (param, i) {
                                  if (i < startIdx) {
                                    return true;
                                  } else {
                                    return i > endIdx;
                                  }
                                });
                            var newPauseIndices = Core__Array.filterMap(transcriptionState.pauseAfterIndices, (function (idx) {
                                    if (idx < startIdx) {
                                      return idx;
                                    } else if (idx <= endIdx) {
                                      return ;
                                    } else {
                                      return idx - removedWordCount | 0;
                                    }
                                  }));
                            var newCueRanges = cueRanges.filter(function (param, i) {
                                    return i !== index;
                                  }).map(function (param) {
                                  var e = param[1];
                                  var s = param[0];
                                  if (s > endIdx) {
                                    return [
                                            s - removedWordCount | 0,
                                            e - removedWordCount | 0
                                          ];
                                  } else {
                                    return [
                                            s,
                                            e
                                          ];
                                  }
                                });
                            setTranscriptionState(function (param) {
                                  return {
                                          TAG: "SubtitlesReady",
                                          wordChunks: newWordChunks,
                                          pauseAfterIndices: newPauseIndices,
                                          cueRanges: newCueRanges,
                                          size: size
                                        };
                                });
                          }),
                        editText: (function (index, newText) {
                            if (typeof transcriptionState !== "object") {
                              return ;
                            }
                            var size = transcriptionState.size;
                            var cueRanges = transcriptionState.cueRanges;
                            var pauseAfterIndices = transcriptionState.pauseAfterIndices;
                            var wordChunks = transcriptionState.wordChunks;
                            var match = cueRanges[index];
                            if (match === undefined) {
                              return ;
                            }
                            var endIdx = match[1];
                            var startIdx = match[0];
                            var oldWordCount = (endIdx - startIdx | 0) + 1 | 0;
                            var cueWords = wordChunks.slice(startIdx, endIdx + 1 | 0);
                            var newCueWords = WordTimestamps.applyTextEdit(cueWords, newText);
                            var newWordCount = newCueWords.length;
                            if (newWordCount === 0) {
                              var firstWord = cueWords[0];
                              var lastWord = cueWords[cueWords.length - 1 | 0];
                              var emptyWord_timestamp = [
                                WordTimestamps.start(firstWord),
                                WordTimestamps.end_(lastWord)
                              ];
                              var emptyWord = {
                                text: "",
                                timestamp: emptyWord_timestamp
                              };
                              var wordsBefore = wordChunks.slice(0, startIdx);
                              var wordsAfter = wordChunks.slice(endIdx + 1 | 0);
                              var newWordChunks = wordsBefore.concat([emptyWord]).concat(wordsAfter);
                              var newPauseIndices = updatePauseIndicesAfterEdit(pauseAfterIndices, startIdx, endIdx, oldWordCount, 1);
                              var newCueRanges = updateRangesAfterEdit(cueRanges, index, oldWordCount, 1);
                              return setTranscriptionState(function (param) {
                                          return {
                                                  TAG: "SubtitlesReady",
                                                  wordChunks: newWordChunks,
                                                  pauseAfterIndices: newPauseIndices,
                                                  cueRanges: newCueRanges,
                                                  size: size
                                                };
                                        });
                            }
                            var wordsBefore$1 = wordChunks.slice(0, startIdx);
                            var wordsAfter$1 = wordChunks.slice(endIdx + 1 | 0);
                            var newWordChunks$1 = wordsBefore$1.concat(newCueWords).concat(wordsAfter$1);
                            var newPauseIndices$1 = updatePauseIndicesAfterEdit(pauseAfterIndices, startIdx, endIdx, oldWordCount, newWordCount);
                            var newCueRanges$1 = updateRangesAfterEdit(cueRanges, index, oldWordCount, newWordCount);
                            setTranscriptionState(function (param) {
                                  return {
                                          TAG: "SubtitlesReady",
                                          wordChunks: newWordChunks$1,
                                          pauseAfterIndices: newPauseIndices$1,
                                          cueRanges: newCueRanges$1,
                                          size: size
                                        };
                                });
                          }),
                        editTimestamp: (function (index, newTimestamp) {
                            if (typeof transcriptionState !== "object") {
                              return ;
                            }
                            var size = transcriptionState.size;
                            var cueRanges = transcriptionState.cueRanges;
                            var pauseAfterIndices = transcriptionState.pauseAfterIndices;
                            var match = cueRanges[index];
                            if (match === undefined) {
                              return ;
                            }
                            var newEnd = newTimestamp[1];
                            var newStart = newTimestamp[0];
                            var endIdx = match[1];
                            var startIdx = match[0];
                            var newWordChunks = transcriptionState.wordChunks.map(function (word, i) {
                                  if (i === startIdx) {
                                    return {
                                            text: word.text,
                                            timestamp: [
                                              newStart,
                                              word.timestamp[1]
                                            ]
                                          };
                                  } else if (i === endIdx) {
                                    return {
                                            text: word.text,
                                            timestamp: [
                                              word.timestamp[0],
                                              newEnd
                                            ]
                                          };
                                  } else {
                                    return word;
                                  }
                                });
                            setTranscriptionState(function (param) {
                                  return {
                                          TAG: "SubtitlesReady",
                                          wordChunks: newWordChunks,
                                          pauseAfterIndices: pauseAfterIndices,
                                          cueRanges: cueRanges,
                                          size: size
                                        };
                                });
                          }),
                        getWordChunksForCue: (function (cueIndex) {
                            if (typeof transcriptionState !== "object") {
                              return ;
                            }
                            var match = transcriptionState.cueRanges[cueIndex];
                            if (match !== undefined) {
                              return transcriptionState.wordChunks.slice(match[0], match[1] + 1 | 0);
                            }
                            
                          })
                      };
              }), [
              transcriptionState,
              subtitles
            ]);
}

var make = React.memo(function (props) {
      var subtitlesManager = props.subtitlesManager;
      var ctx = EditorContext.useEditorContext();
      var match = ctx.usePlayer();
      var player = match[0];
      var match$1 = subtitlesManager.transcriptionState;
      var tmp;
      if (typeof match$1 !== "object") {
        tmp = JsxRuntime.jsx("p", {
              children: "Transcription in progress. Once finished you'll be able to edit and resize generated subtitles.",
              className: "text-center px-2 text-balance text-sm text-gray-500"
            });
      } else {
        var size = match$1.size;
        tmp = JsxRuntime.jsxs(JsxRuntime.Fragment, {
              children: [
                JsxRuntime.jsx("h3", {
                      children: "Cue size " + size.toString() + " characters",
                      className: "text-center font-medium text-white/95"
                    }),
                JsxRuntime.jsx(Slider.make, {
                      onValueChange: subtitlesManager.resizeSubtitles,
                      disabled: false,
                      value: size,
                      min: 5,
                      max: 200,
                      step: 1
                    })
              ]
            });
      }
      return JsxRuntime.jsxs(JsxRuntime.Fragment, {
                  children: [
                    JsxRuntime.jsxs("div", {
                          children: [
                            JsxRuntime.jsx("h2", {
                                  children: props.title,
                                  className: "mx-auto text-xl pb-2"
                                }),
                            tmp
                          ],
                          className: "sticky top-0 z-10 px-2 bg-zinc-900 flex flex-col w-full"
                        }),
                    JsxRuntime.jsx("div", {
                          children: subtitlesManager.activeSubtitles.map(function (chunk, index) {
                                var id = chunk.id;
                                return JsxRuntime.jsx(ChunkEditor.make, {
                                            index: index,
                                            readonly: subtitlesManager.transcriptionState === "TranscriptionInProgress",
                                            current: Core__Option.getOr(Core__Option.map(player.currentPlayingCue, (function (cue) {
                                                        return cue.currentIndex === index;
                                                      })), false),
                                            chunk: chunk,
                                            removeChunk: subtitlesManager.removeChunk,
                                            onTimestampChange: subtitlesManager.editTimestamp,
                                            onTextChange: subtitlesManager.editText
                                          }, id !== undefined ? id.toString() : index.toString() + "-" + chunk.text);
                              }),
                          className: "flex flex-1 ml-1.5 pb-4 min-h-0 flex-col gap-6"
                        })
                  ]
                });
    });

export {
  subtitleCueToWordChunk ,
  detectPauseIndices ,
  groupByPauses ,
  resizeGroupsToRanges ,
  calculateCueRanges ,
  buildCueFromRange ,
  buildCuesFromRanges ,
  updatePauseIndicesAfterEdit ,
  updateRangesAfterEdit ,
  useChunksState ,
  make ,
}
/* make Not a pure module */
