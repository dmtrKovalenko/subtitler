// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "rescript/lib/es6/caml.js";
import * as React from "react";
import * as Slider from "../../../ui/Slider.res.mjs";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as ChunkEditor from "./ChunkEditor.res.mjs";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as EditorContext from "../EditorContext.res.mjs";
import * as WordTimestamps from "../WordTimestamps.res.mjs";
import * as JsxRuntime from "react/jsx-runtime";

function subtitleCueToWordChunk(cue) {
  return {
          text: cue.text,
          timestamp: cue.timestamp
        };
}

function detectPauseIndices(wordChunks) {
  var pauseIndices = [];
  wordChunks.forEach(function (chunk, i) {
        var nextChunk = wordChunks[i + 1 | 0];
        if (nextChunk === undefined) {
          return ;
        }
        var thisEnd = Core__Option.getOr(Caml_option.nullable_to_opt(chunk.timestamp[1]), chunk.timestamp[0]);
        var nextStart = nextChunk.timestamp[0];
        if (nextStart - thisEnd > 0.2) {
          pauseIndices.push(i);
          return ;
        }
        
      });
  return pauseIndices;
}

function groupByPauses(wordCount, pauseAfterIndices) {
  if (wordCount === 0) {
    return [];
  }
  var groups = [];
  var currentStart = {
    contents: 0
  };
  pauseAfterIndices.forEach(function (pauseAfterIdx) {
        if (pauseAfterIdx >= currentStart.contents && pauseAfterIdx < wordCount) {
          groups.push([
                currentStart.contents,
                pauseAfterIdx
              ]);
          currentStart.contents = pauseAfterIdx + 1 | 0;
          return ;
        }
        
      });
  if (currentStart.contents < wordCount) {
    groups.push([
          currentStart.contents,
          wordCount - 1 | 0
        ]);
  }
  return groups;
}

function resizeGroupsToRanges(wordChunks, groups, maxSize) {
  return groups.flatMap(function (param) {
              var groupEnd = param[1];
              var groupStart = param[0];
              var groupWords = wordChunks.slice(groupStart, groupEnd + 1 | 0);
              var totalLength = Core__Array.reduce(groupWords, 0, (function (acc, w) {
                      return acc + w.text.trim().length | 0;
                    }));
              if (!(totalLength > maxSize && groupWords.length > 1)) {
                return [[
                          groupStart,
                          groupEnd
                        ]];
              }
              var relation = totalLength / maxSize;
              var subChunkSize = Math.ceil(groupWords.length / relation) | 0;
              var ranges = [];
              var numSubChunks = Math.ceil(groupWords.length / subChunkSize) | 0;
              for(var i = 0; i < numSubChunks; ++i){
                var localStart = Math.imul(i, subChunkSize);
                var localEnd = Caml.int_min(Math.imul(i + 1 | 0, subChunkSize) - 1 | 0, groupWords.length - 1 | 0);
                if (localStart <= localEnd) {
                  ranges.push([
                        groupStart + localStart | 0,
                        groupStart + localEnd | 0
                      ]);
                }
                
              }
              return ranges;
            });
}

function calculateCueRanges(wordChunks, pauseAfterIndices, size) {
  var groups = groupByPauses(wordChunks.length, pauseAfterIndices);
  return resizeGroupsToRanges(wordChunks, groups, size);
}

function buildCueFromRange(wordChunks, startIdx, endIdx) {
  var words = wordChunks.slice(startIdx, endIdx + 1 | 0);
  var firstWord = words[0];
  var lastWord = words[words.length - 1 | 0];
  var combinedText = words.map(function (w) {
            return w.text.trim();
          }).filter(function (s) {
          return s !== "";
        }).join(" ");
  return {
          id: Math.random(),
          text: combinedText,
          isInProgress: undefined,
          timestamp: [
            WordTimestamps.start(firstWord),
            WordTimestamps.end_(lastWord)
          ]
        };
}

function buildCuesFromRanges(wordChunks, cueRanges) {
  return cueRanges.map(function (param) {
              return buildCueFromRange(wordChunks, param[0], param[1]);
            });
}

function updatePauseIndicesAfterEdit(pauseAfterIndices, editedCueStart, editedCueEnd, oldWordCount, newWordCount) {
  var delta = newWordCount - oldWordCount | 0;
  if (delta === 0) {
    return pauseAfterIndices;
  } else {
    return Core__Array.filterMap(pauseAfterIndices, (function (idx) {
                  if (idx < editedCueStart) {
                    return idx;
                  }
                  if (!(idx >= editedCueStart && idx <= editedCueEnd)) {
                    return idx + delta | 0;
                  }
                  if (newWordCount === 0) {
                    return ;
                  }
                  var relativePos = (idx - editedCueStart | 0) / oldWordCount;
                  var newIdx = editedCueStart + (relativePos * newWordCount | 0) | 0;
                  if (newIdx < ((editedCueStart + newWordCount | 0) - 1 | 0)) {
                    return newIdx;
                  }
                  
                }));
  }
}

function updateRangesAfterEdit(cueRanges, editedCueIndex, oldWordCount, newWordCount) {
  var delta = newWordCount - oldWordCount | 0;
  if (delta === 0) {
    return cueRanges;
  } else {
    return cueRanges.map(function (range, i) {
                var startIdx = range[0];
                if (i === editedCueIndex) {
                  return [
                          startIdx,
                          (startIdx + newWordCount | 0) - 1 | 0
                        ];
                } else if (i > editedCueIndex) {
                  return [
                          startIdx + delta | 0,
                          range[1] + delta | 0
                        ];
                } else {
                  return range;
                }
              });
  }
}

function useChunksState(subtitles, transcriptionInProgress, default_chunk_size) {
  var subtitlesRef = React.useRef(subtitles);
  var match = React.useState(function () {
        return "TranscriptionInProgress";
      });
  var setTranscriptionState = match[1];
  var transcriptionState = match[0];
  if (!transcriptionInProgress && typeof transcriptionState !== "object" && subtitles.length > 0) {
    var wordChunks = subtitles.map(subtitleCueToWordChunk);
    var pauseAfterIndices = detectPauseIndices(wordChunks);
    var cueRanges = calculateCueRanges(wordChunks, pauseAfterIndices, default_chunk_size);
    setTranscriptionState(function (param) {
          return {
                  TAG: "SubtitlesReady",
                  wordChunks: wordChunks,
                  pauseAfterIndices: pauseAfterIndices,
                  cueRanges: cueRanges,
                  size: default_chunk_size
                };
        });
  }
  var activeSubtitles;
  activeSubtitles = typeof transcriptionState !== "object" ? subtitles : buildCuesFromRanges(transcriptionState.wordChunks, transcriptionState.cueRanges);
  subtitlesRef.current = activeSubtitles;
  return React.useMemo((function () {
                return {
                        activeSubtitles: activeSubtitles,
                        transcriptionState: transcriptionState,
                        subtitlesRef: subtitlesRef,
                        resizeSubtitles: (function (newSize) {
                            if (typeof transcriptionState !== "object") {
                              return ;
                            }
                            var pauseAfterIndices = transcriptionState.pauseAfterIndices;
                            var wordChunks = transcriptionState.wordChunks;
                            var newCueRanges = calculateCueRanges(wordChunks, pauseAfterIndices, newSize);
                            setTranscriptionState(function (param) {
                                  return {
                                          TAG: "SubtitlesReady",
                                          wordChunks: wordChunks,
                                          pauseAfterIndices: pauseAfterIndices,
                                          cueRanges: newCueRanges,
                                          size: newSize
                                        };
                                });
                          }),
                        removeChunk: (function (index, param) {
                            if (typeof transcriptionState !== "object") {
                              return ;
                            }
                            var size = transcriptionState.size;
                            var cueRanges = transcriptionState.cueRanges;
                            var match = cueRanges[index];
                            if (match === undefined) {
                              return ;
                            }
                            var endIdx = match[1];
                            var startIdx = match[0];
                            var removedWordCount = (endIdx - startIdx | 0) + 1 | 0;
                            var newWordChunks = transcriptionState.wordChunks.filter(function (param, i) {
                                  if (i < startIdx) {
                                    return true;
                                  } else {
                                    return i > endIdx;
                                  }
                                });
                            var newPauseIndices = Core__Array.filterMap(transcriptionState.pauseAfterIndices, (function (idx) {
                                    if (idx < startIdx) {
                                      return idx;
                                    } else if (idx <= endIdx) {
                                      return ;
                                    } else {
                                      return idx - removedWordCount | 0;
                                    }
                                  }));
                            var newCueRanges = cueRanges.filter(function (param, i) {
                                    return i !== index;
                                  }).map(function (param) {
                                  var e = param[1];
                                  var s = param[0];
                                  if (s > endIdx) {
                                    return [
                                            s - removedWordCount | 0,
                                            e - removedWordCount | 0
                                          ];
                                  } else {
                                    return [
                                            s,
                                            e
                                          ];
                                  }
                                });
                            setTranscriptionState(function (param) {
                                  return {
                                          TAG: "SubtitlesReady",
                                          wordChunks: newWordChunks,
                                          pauseAfterIndices: newPauseIndices,
                                          cueRanges: newCueRanges,
                                          size: size
                                        };
                                });
                          }),
                        editText: (function (index, newText) {
                            if (typeof transcriptionState !== "object") {
                              return ;
                            }
                            var size = transcriptionState.size;
                            var cueRanges = transcriptionState.cueRanges;
                            var pauseAfterIndices = transcriptionState.pauseAfterIndices;
                            var wordChunks = transcriptionState.wordChunks;
                            var match = cueRanges[index];
                            if (match === undefined) {
                              return ;
                            }
                            var endIdx = match[1];
                            var startIdx = match[0];
                            var oldWordCount = (endIdx - startIdx | 0) + 1 | 0;
                            var cueWords = wordChunks.slice(startIdx, endIdx + 1 | 0);
                            var newCueWords = WordTimestamps.applyTextEdit(cueWords, newText);
                            var newWordCount = newCueWords.length;
                            if (newWordCount === 0) {
                              var firstWord = cueWords[0];
                              var lastWord = cueWords[cueWords.length - 1 | 0];
                              var emptyWord_timestamp = [
                                WordTimestamps.start(firstWord),
                                WordTimestamps.end_(lastWord)
                              ];
                              var emptyWord = {
                                text: "",
                                timestamp: emptyWord_timestamp
                              };
                              var wordsBefore = wordChunks.slice(0, startIdx);
                              var wordsAfter = wordChunks.slice(endIdx + 1 | 0);
                              var newWordChunks = wordsBefore.concat([emptyWord]).concat(wordsAfter);
                              var newPauseIndices = updatePauseIndicesAfterEdit(pauseAfterIndices, startIdx, endIdx, oldWordCount, 1);
                              var newCueRanges = updateRangesAfterEdit(cueRanges, index, oldWordCount, 1);
                              return setTranscriptionState(function (param) {
                                          return {
                                                  TAG: "SubtitlesReady",
                                                  wordChunks: newWordChunks,
                                                  pauseAfterIndices: newPauseIndices,
                                                  cueRanges: newCueRanges,
                                                  size: size
                                                };
                                        });
                            }
                            var wordsBefore$1 = wordChunks.slice(0, startIdx);
                            var wordsAfter$1 = wordChunks.slice(endIdx + 1 | 0);
                            var newWordChunks$1 = wordsBefore$1.concat(newCueWords).concat(wordsAfter$1);
                            var newPauseIndices$1 = updatePauseIndicesAfterEdit(pauseAfterIndices, startIdx, endIdx, oldWordCount, newWordCount);
                            var newCueRanges$1 = updateRangesAfterEdit(cueRanges, index, oldWordCount, newWordCount);
                            setTranscriptionState(function (param) {
                                  return {
                                          TAG: "SubtitlesReady",
                                          wordChunks: newWordChunks$1,
                                          pauseAfterIndices: newPauseIndices$1,
                                          cueRanges: newCueRanges$1,
                                          size: size
                                        };
                                });
                          }),
                        editTimestamp: (function (index, newTimestamp) {
                            if (typeof transcriptionState !== "object") {
                              return ;
                            }
                            var size = transcriptionState.size;
                            var cueRanges = transcriptionState.cueRanges;
                            var pauseAfterIndices = transcriptionState.pauseAfterIndices;
                            var match = cueRanges[index];
                            if (match === undefined) {
                              return ;
                            }
                            var newEnd = newTimestamp[1];
                            var newStart = newTimestamp[0];
                            var endIdx = match[1];
                            var startIdx = match[0];
                            var newWordChunks = transcriptionState.wordChunks.map(function (word, i) {
                                  if (i === startIdx) {
                                    return {
                                            text: word.text,
                                            timestamp: [
                                              newStart,
                                              word.timestamp[1]
                                            ]
                                          };
                                  } else if (i === endIdx) {
                                    return {
                                            text: word.text,
                                            timestamp: [
                                              word.timestamp[0],
                                              newEnd
                                            ]
                                          };
                                  } else {
                                    return word;
                                  }
                                });
                            setTranscriptionState(function (param) {
                                  return {
                                          TAG: "SubtitlesReady",
                                          wordChunks: newWordChunks,
                                          pauseAfterIndices: pauseAfterIndices,
                                          cueRanges: cueRanges,
                                          size: size
                                        };
                                });
                          }),
                        getWordChunksForCue: (function (cueIndex) {
                            if (typeof transcriptionState !== "object") {
                              return ;
                            }
                            var match = transcriptionState.cueRanges[cueIndex];
                            if (match !== undefined) {
                              return transcriptionState.wordChunks.slice(match[0], match[1] + 1 | 0);
                            }
                            
                          }),
                        hasPauseBefore: (function (cueIndex) {
                            if (typeof transcriptionState !== "object") {
                              return false;
                            }
                            var cueRanges = transcriptionState.cueRanges;
                            var wordChunks = transcriptionState.wordChunks;
                            var match = cueRanges[cueIndex];
                            var match$1 = cueRanges[cueIndex - 1 | 0];
                            if (match === undefined) {
                              return false;
                            }
                            var startIdx = match[0];
                            if (match$1 !== undefined) {
                              var currentStart = Core__Option.getOr(Core__Option.map(wordChunks[startIdx], (function (w) {
                                          return w.timestamp[0];
                                        })), 0.0);
                              var prevEnd = Core__Option.getOr(Core__Option.flatMap(wordChunks[match$1[1]], (function (w) {
                                          return Caml_option.nullable_to_opt(w.timestamp[1]);
                                        })), 0.0);
                              return currentStart - prevEnd > 0.1;
                            }
                            var currentStart$1 = Core__Option.getOr(Core__Option.map(wordChunks[startIdx], (function (w) {
                                        return w.timestamp[0];
                                      })), 0.0);
                            return currentStart$1 > 0.1;
                          }),
                        hasPauseAfter: (function (cueIndex) {
                            if (typeof transcriptionState !== "object") {
                              return false;
                            }
                            var cueRanges = transcriptionState.cueRanges;
                            var wordChunks = transcriptionState.wordChunks;
                            var match = cueRanges[cueIndex];
                            var match$1 = cueRanges[cueIndex + 1 | 0];
                            if (match === undefined) {
                              return false;
                            }
                            var endIdx = match[1];
                            if (match$1 === undefined) {
                              return Core__Option.isSome(Core__Option.flatMap(wordChunks[endIdx], (function (w) {
                                                return Caml_option.nullable_to_opt(w.timestamp[1]);
                                              })));
                            }
                            var currentEnd = Core__Option.getOr(Core__Option.flatMap(wordChunks[endIdx], (function (w) {
                                        return Caml_option.nullable_to_opt(w.timestamp[1]);
                                      })), 0.0);
                            var nextStart = Core__Option.getOr(Core__Option.map(wordChunks[match$1[0]], (function (w) {
                                        return w.timestamp[0];
                                      })), 0.0);
                            return nextStart - currentEnd > 0.1;
                          }),
                        addCueBefore: (function (cueIndex) {
                            if (typeof transcriptionState !== "object") {
                              return ;
                            }
                            var size = transcriptionState.size;
                            var cueRanges = transcriptionState.cueRanges;
                            var wordChunks = transcriptionState.wordChunks;
                            var match = cueRanges[cueIndex];
                            if (match === undefined) {
                              return ;
                            }
                            var startIdx = match[0];
                            var currentStart = Core__Option.getOr(Core__Option.map(wordChunks[startIdx], (function (w) {
                                        return w.timestamp[0];
                                      })), 0.0);
                            var match$1 = cueRanges[cueIndex - 1 | 0];
                            var gapStart = match$1 !== undefined ? Core__Option.getOr(Core__Option.flatMap(wordChunks[match$1[1]], (function (w) {
                                          return Caml_option.nullable_to_opt(w.timestamp[1]);
                                        })), 0.0) : 0.0;
                            var newWordChunk_timestamp = [
                              gapStart,
                              currentStart
                            ];
                            var newWordChunk = {
                              text: "",
                              timestamp: newWordChunk_timestamp
                            };
                            var wordsBefore = wordChunks.slice(0, startIdx);
                            var wordsAfter = wordChunks.slice(startIdx);
                            var newWordChunks = wordsBefore.concat([newWordChunk]).concat(wordsAfter);
                            var newPauseIndices = transcriptionState.pauseAfterIndices.map(function (idx) {
                                  if (idx >= startIdx) {
                                    return idx + 1 | 0;
                                  } else {
                                    return idx;
                                  }
                                });
                            var newCueRange = [
                              startIdx,
                              startIdx
                            ];
                            var shiftedRanges = cueRanges.map(function (param) {
                                  var e = param[1];
                                  var s = param[0];
                                  if (s >= startIdx) {
                                    return [
                                            s + 1 | 0,
                                            e + 1 | 0
                                          ];
                                  } else {
                                    return [
                                            s,
                                            e
                                          ];
                                  }
                                });
                            var newCueRanges = shiftedRanges.slice(0, cueIndex).concat([newCueRange]).concat(shiftedRanges.slice(cueIndex));
                            setTranscriptionState(function (param) {
                                  return {
                                          TAG: "SubtitlesReady",
                                          wordChunks: newWordChunks,
                                          pauseAfterIndices: newPauseIndices,
                                          cueRanges: newCueRanges,
                                          size: size
                                        };
                                });
                          }),
                        addCueAfter: (function (cueIndex) {
                            if (typeof transcriptionState !== "object") {
                              return ;
                            }
                            var size = transcriptionState.size;
                            var cueRanges = transcriptionState.cueRanges;
                            var wordChunks = transcriptionState.wordChunks;
                            var match = cueRanges[cueIndex];
                            if (match === undefined) {
                              return ;
                            }
                            var endIdx = match[1];
                            var currentEnd = Core__Option.getOr(Core__Option.flatMap(wordChunks[endIdx], (function (w) {
                                        return Caml_option.nullable_to_opt(w.timestamp[1]);
                                      })), 0.0);
                            var match$1 = cueRanges[cueIndex + 1 | 0];
                            var gapEnd = match$1 !== undefined ? Core__Option.getOr(Core__Option.map(wordChunks[match$1[0]], (function (w) {
                                          return w.timestamp[0];
                                        })), 0.0) : currentEnd + 1.0;
                            var newWordChunk_timestamp = [
                              currentEnd,
                              gapEnd
                            ];
                            var newWordChunk = {
                              text: "",
                              timestamp: newWordChunk_timestamp
                            };
                            var insertIdx = endIdx + 1 | 0;
                            var wordsBefore = wordChunks.slice(0, insertIdx);
                            var wordsAfter = wordChunks.slice(insertIdx);
                            var newWordChunks = wordsBefore.concat([newWordChunk]).concat(wordsAfter);
                            var newPauseIndices = transcriptionState.pauseAfterIndices.map(function (idx) {
                                  if (idx >= insertIdx) {
                                    return idx + 1 | 0;
                                  } else {
                                    return idx;
                                  }
                                });
                            var newCueRange = [
                              insertIdx,
                              insertIdx
                            ];
                            var rangesBefore = cueRanges.slice(0, cueIndex + 1 | 0);
                            var rangesAfter = cueRanges.slice(cueIndex + 1 | 0).map(function (param) {
                                  return [
                                          param[0] + 1 | 0,
                                          param[1] + 1 | 0
                                        ];
                                });
                            var newCueRanges = rangesBefore.concat([newCueRange]).concat(rangesAfter);
                            setTranscriptionState(function (param) {
                                  return {
                                          TAG: "SubtitlesReady",
                                          wordChunks: newWordChunks,
                                          pauseAfterIndices: newPauseIndices,
                                          cueRanges: newCueRanges,
                                          size: size
                                        };
                                });
                          }),
                        splitCue: (function (cueIndex, splitAtWordIndex) {
                            if (typeof transcriptionState !== "object") {
                              return ;
                            }
                            var size = transcriptionState.size;
                            var cueRanges = transcriptionState.cueRanges;
                            var pauseAfterIndices = transcriptionState.pauseAfterIndices;
                            var wordChunks = transcriptionState.wordChunks;
                            var match = cueRanges[cueIndex];
                            if (match === undefined) {
                              return ;
                            }
                            var endIdx = match[1];
                            var startIdx = match[0];
                            var wordCount = (endIdx - startIdx | 0) + 1 | 0;
                            if (!(splitAtWordIndex > 0 && splitAtWordIndex < wordCount)) {
                              return ;
                            }
                            var absoluteSplitIdx = startIdx + splitAtWordIndex | 0;
                            var firstRange_1 = absoluteSplitIdx - 1 | 0;
                            var firstRange = [
                              startIdx,
                              firstRange_1
                            ];
                            var secondRange = [
                              absoluteSplitIdx,
                              endIdx
                            ];
                            var rangesBefore = cueRanges.slice(0, cueIndex);
                            var rangesAfter = cueRanges.slice(cueIndex + 1 | 0);
                            var newCueRanges = rangesBefore.concat([
                                    firstRange,
                                    secondRange
                                  ]).concat(rangesAfter);
                            setTranscriptionState(function (param) {
                                  return {
                                          TAG: "SubtitlesReady",
                                          wordChunks: wordChunks,
                                          pauseAfterIndices: pauseAfterIndices,
                                          cueRanges: newCueRanges,
                                          size: size
                                        };
                                });
                          })
                      };
              }), [
              transcriptionState,
              subtitles
            ]);
}

var emptyWordChunks = [];

var make = React.memo(function (props) {
      var subtitlesManager = props.subtitlesManager;
      var ctx = EditorContext.useEditorContext();
      var currentPlayingCueIndex = ctx.usePlayerSelector(function (player) {
            return Core__Option.map(player.currentPlayingCue, (function (cue) {
                          return cue.currentIndex;
                        }));
          });
      var match = React.useState(function () {
            
          });
      var setSplitPreviewState = match[1];
      var splitPreviewState = match[0];
      var match$1 = React.useState(function () {
            
          });
      var setFocusCueIndex = match$1[1];
      var focusCueIndex = match$1[0];
      var handleAddBefore = React.useCallback((function (index) {
              subtitlesManager.addCueBefore(index);
              setFocusCueIndex(function (param) {
                    return index;
                  });
            }), [subtitlesManager.addCueBefore]);
      var handleAddAfter = React.useCallback((function (index) {
              subtitlesManager.addCueAfter(index);
              setFocusCueIndex(function (param) {
                    return index + 1 | 0;
                  });
            }), [subtitlesManager.addCueAfter]);
      var handleSplit = React.useCallback((function (param) {
              var index = param[0];
              subtitlesManager.splitCue(index, param[1]);
              setFocusCueIndex(function (param) {
                    return index + 1 | 0;
                  });
            }), [subtitlesManager.splitCue]);
      var handleSplitPreviewChange = React.useCallback((function (param) {
              var preview = param[1];
              var index = param[0];
              setSplitPreviewState(function (param) {
                    return Core__Option.map(preview, (function (splitAt) {
                                  return [
                                          index,
                                          splitAt
                                        ];
                                }));
                  });
            }), []);
      var handleFocused = React.useCallback((function () {
              setFocusCueIndex(function (param) {
                    
                  });
            }), []);
      var isAnySplitPreviewActive = Core__Option.isSome(splitPreviewState);
      var match$2 = subtitlesManager.transcriptionState;
      var tmp;
      if (typeof match$2 !== "object") {
        tmp = JsxRuntime.jsx("p", {
              children: "Transcription in progress. Once finished you'll be able to edit and resize generated subtitles.",
              className: "text-center pb-4 px-2 text-balance text-sm text-gray-500"
            });
      } else {
        var size = match$2.size;
        tmp = JsxRuntime.jsxs(JsxRuntime.Fragment, {
              children: [
                JsxRuntime.jsx("h3", {
                      children: "Cue size " + size.toString() + " characters",
                      className: "text-center font-medium text-white/95"
                    }),
                JsxRuntime.jsx(Slider.make, {
                      onValueChange: subtitlesManager.resizeSubtitles,
                      disabled: false,
                      value: size,
                      min: 5,
                      max: 200,
                      step: 1
                    })
              ]
            });
      }
      return JsxRuntime.jsxs(JsxRuntime.Fragment, {
                  children: [
                    JsxRuntime.jsxs("div", {
                          children: [
                            JsxRuntime.jsx("h2", {
                                  children: props.title,
                                  className: "mx-auto text-xl pb-2"
                                }),
                            tmp
                          ],
                          className: "sticky -top-px z-10 py-2 flex flex-col w-full bg-zinc-950 md:bg-zinc-900/95 md:backdrop-blur-sm border-b border-zinc-800/50"
                        }),
                    JsxRuntime.jsx("div", {
                          children: subtitlesManager.activeSubtitles.map(function (chunk, index) {
                                var id = chunk.id;
                                return JsxRuntime.jsx(ChunkEditor.make, {
                                            index: index,
                                            readonly: subtitlesManager.transcriptionState === "TranscriptionInProgress",
                                            current: Core__Option.getOr(Core__Option.map(currentPlayingCueIndex, (function (i) {
                                                        return i === index;
                                                      })), false),
                                            chunk: chunk,
                                            removeChunk: subtitlesManager.removeChunk,
                                            onTimestampChange: subtitlesManager.editTimestamp,
                                            onTextChange: subtitlesManager.editText,
                                            hasPauseBefore: subtitlesManager.hasPauseBefore(index),
                                            hasPauseAfter: subtitlesManager.hasPauseAfter(index),
                                            wordChunks: Core__Option.getOr(subtitlesManager.getWordChunksForCue(index), emptyWordChunks),
                                            onAddBefore: (function () {
                                                handleAddBefore(index);
                                              }),
                                            onAddAfter: (function () {
                                                handleAddAfter(index);
                                              }),
                                            onSplit: (function (splitIdx) {
                                                handleSplit([
                                                      index,
                                                      splitIdx
                                                    ]);
                                              }),
                                            splitPreview: Core__Option.flatMap(splitPreviewState, (function (param) {
                                                    if (param[0] === index) {
                                                      return param[1];
                                                    }
                                                    
                                                  })),
                                            onSplitPreviewChange: (function (preview) {
                                                handleSplitPreviewChange([
                                                      index,
                                                      preview
                                                    ]);
                                              }),
                                            isAnySplitPreviewActive: isAnySplitPreviewActive,
                                            shouldFocus: Core__Option.getOr(Core__Option.map(focusCueIndex, (function (i) {
                                                        return i === index;
                                                      })), false),
                                            onFocused: handleFocused
                                          }, id !== undefined ? id.toString() : index.toString() + "-" + chunk.text);
                              }),
                          className: "flex flex-1 ml-1.5 pb-4 min-h-0 flex-col gap-6"
                        })
                  ]
                });
    });

var pauseThreshold = 0.1;

export {
  subtitleCueToWordChunk ,
  detectPauseIndices ,
  groupByPauses ,
  resizeGroupsToRanges ,
  calculateCueRanges ,
  buildCueFromRange ,
  buildCuesFromRanges ,
  updatePauseIndicesAfterEdit ,
  updateRangesAfterEdit ,
  pauseThreshold ,
  useChunksState ,
  emptyWordChunks ,
  make ,
}
/* make Not a pure module */
