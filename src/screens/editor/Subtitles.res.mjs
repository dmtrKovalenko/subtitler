// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "../../Utils.res.mjs";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";

function start(chunk) {
  return chunk.timestamp[0];
}

function end(chunk) {
  return chunk.timestamp[1];
}

function isChunkDisplayed(range, ts, nextRange) {
  var match = range.timestamp[0];
  var match$1 = range.timestamp[1];
  var match$2 = Core__Option.map(nextRange, start);
  if (!(match$1 === null || match$1 === undefined)) {
    if (match <= ts) {
      return ts < match$1;
    } else {
      return false;
    }
  }
  match$1 === null;
  if (match$2 !== undefined) {
    if (match <= ts) {
      return ts < match$2;
    } else {
      return false;
    }
  } else {
    return ts >= match;
  }
}

function lookupCurrentCue(subtitles, timestamp) {
  return Core__Option.map((function (index) {
                  if (index < 0) {
                    return ;
                  } else {
                    return index;
                  }
                })(subtitles.findIndex(function (subtitle, i) {
                      return isChunkDisplayed(subtitle, timestamp, subtitles[i + 1 | 0]);
                    })), (function (currentIndex) {
                var currentCue = subtitles[currentIndex];
                return {
                        currentIndex: currentIndex,
                        currentCue: currentCue
                      };
              }));
}

function lookUpLastPlayedCue(subtitles, timestamp) {
  return Core__Array.reduceRightWithIndex(subtitles, undefined, (function (acc, subtitle, index) {
                if (acc !== undefined || !isChunkDisplayed(subtitle, timestamp, subtitles[index + 1 | 0])) {
                  return acc;
                } else {
                  return {
                          currentIndex: index,
                          currentCue: subtitle
                        };
                }
              }));
}

function getOrLookupCurrentCue(timestamp, subtitles, prevCue) {
  if (prevCue !== undefined) {
    if (isChunkDisplayed(prevCue.currentCue, timestamp, subtitles[prevCue.currentIndex + 1 | 0])) {
      return prevCue;
    } else {
      return Core__Option.flatMap(subtitles[prevCue.currentIndex + 1 | 0], (function (nextCue) {
                    if (isChunkDisplayed(nextCue, timestamp, subtitles[prevCue.currentIndex + 2 | 0])) {
                      return {
                              currentIndex: prevCue.currentIndex + 1 | 0,
                              currentCue: nextCue
                            };
                    } else {
                      return lookupCurrentCue(subtitles, timestamp);
                    }
                  }));
    }
  } else {
    return lookupCurrentCue(subtitles, timestamp);
  }
}

function averageChunkLength(subtitles) {
  var totalCharacters = Core__Array.reduce(subtitles, 0, (function (acc, subtitle) {
          return acc + subtitle.text.length | 0;
        }));
  return Caml_int32.div(totalCharacters, subtitles.length);
}

function addChunkId(chunk) {
  return {
          id: Math.random(),
          text: chunk.text,
          timestamp: chunk.timestamp
        };
}

function fillChunksIds(subtitles) {
  return subtitles.map(addChunkId);
}

function resizeChunks(wordChunks, maxSize) {
  var resizedChunks = [];
  var chunkInProgressRef = {
    contents: undefined
  };
  wordChunks.forEach(function (chunk) {
        var chunk$1 = addChunkId(chunk);
        var chunkInProgress = chunkInProgressRef.contents;
        if (chunkInProgress !== undefined) {
          if ((chunk$1.text.trim().length + chunkInProgress.text.trim().length | 0) < maxSize) {
            chunkInProgressRef.contents = {
              id: Math.random(),
              text: chunkInProgress.text + chunk$1.text,
              timestamp: [
                chunkInProgress.timestamp[0],
                chunk$1.timestamp[1]
              ]
            };
          } else {
            resizedChunks.push(chunkInProgress);
            chunkInProgressRef.contents = chunk$1;
          }
        } else {
          chunkInProgressRef.contents = chunk$1;
        }
      });
  Core__Option.forEach(chunkInProgressRef.contents, (function (chunk) {
          resizedChunks.push(chunk);
        }));
  return resizedChunks;
}

function editChunkText(chunks, index, newText) {
  return chunks.map(function (chunk, i) {
              if (i === index) {
                return {
                        id: chunk.id,
                        text: newText,
                        timestamp: chunk.timestamp
                      };
              } else {
                return chunk;
              }
            });
}

function sortChunks(chunks) {
  return chunks.toSorted(function (a, b) {
              var match = a.timestamp;
              var match$1 = b.timestamp;
              return match[0] - match$1[0];
            });
}

function editChunkTimestamp(chunks, index, newTimestamp) {
  return sortChunks(Utils.Log.andReturn(Utils.Log.andReturn(chunks).map(function (chunk, i) {
                      if (i === index) {
                        return {
                                id: chunk.id,
                                text: chunk.text,
                                timestamp: newTimestamp
                              };
                      } else {
                        return chunk;
                      }
                    })));
}

function removeChunk(chunks, index, joinSiblingsTimestamps) {
  var chunkToRemove = chunks[index];
  return Core__Option.getOr(Utils.Log.andReturn(Core__Option.map(chunkToRemove, (function (chunkToRemove) {
                        return Utils.$$Array.filterMapWithIndex(chunks, (function (chunk, i) {
                                      if (i === index) {
                                        return ;
                                      } else if (joinSiblingsTimestamps && i === (index - 1 | 0)) {
                                        return {
                                                id: chunk.id,
                                                text: chunk.text,
                                                timestamp: [
                                                  chunk.timestamp[0],
                                                  chunkToRemove.timestamp[1]
                                                ]
                                              };
                                      } else if (joinSiblingsTimestamps && i === (index + 1 | 0)) {
                                        return {
                                                id: chunk.id,
                                                text: chunk.text,
                                                timestamp: [
                                                  Core__Option.getOr(Caml_option.nullable_to_opt(chunkToRemove.timestamp[1]), chunk.timestamp[0]),
                                                  chunk.timestamp[1]
                                                ]
                                              };
                                      } else {
                                        return chunk;
                                      }
                                    }));
                      }))), chunks);
}

export {
  start ,
  end ,
  isChunkDisplayed ,
  lookupCurrentCue ,
  lookUpLastPlayedCue ,
  getOrLookupCurrentCue ,
  averageChunkLength ,
  addChunkId ,
  fillChunksIds ,
  resizeChunks ,
  editChunkText ,
  sortChunks ,
  editChunkTimestamp ,
  removeChunk ,
}
/* Utils Not a pure module */
