// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";

function compareTsToRange(range, ts) {
  var end = range[1];
  var start = range[0];
  if (end === null || end === undefined) {
    return Caml_obj.greaterequal(ts, start);
  } else if (Caml_obj.lessequal(start, ts)) {
    return Caml_obj.lessthan(ts, end);
  } else {
    return false;
  }
}

function lookupCurrentCue(subtitles, timestamp) {
  return Core__Option.map(Belt_Array.getIndexBy(subtitles, (function (subtitle) {
                    return compareTsToRange(subtitle.timestamp, timestamp);
                  })), (function (currentIndex) {
                var currentCue = subtitles[currentIndex];
                return {
                        currentIndex: currentIndex,
                        currentCue: currentCue
                      };
              }));
}

function resolveCurrentSubtitle(timestamp, subtitles, prevCue) {
  if (prevCue !== undefined) {
    if (compareTsToRange(prevCue.currentCue.timestamp, timestamp)) {
      return prevCue;
    } else {
      return Core__Option.flatMap(subtitles[prevCue.currentIndex + 1 | 0], (function (nextCue) {
                    if (compareTsToRange(nextCue.timestamp, timestamp)) {
                      return {
                              currentIndex: prevCue.currentIndex + 1 | 0,
                              currentCue: nextCue
                            };
                    } else {
                      return lookupCurrentCue(subtitles, timestamp);
                    }
                  }));
    }
  } else {
    return lookupCurrentCue(subtitles, timestamp);
  }
}

export {
  compareTsToRange ,
  lookupCurrentCue ,
  resolveCurrentSubtitle ,
}
/* No side effect */
