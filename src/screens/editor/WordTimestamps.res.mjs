// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Core__Array from "@rescript/core/src/Core__Array.res.mjs";

function start(chunk) {
  return chunk.timestamp[0];
}

function end_(chunk) {
  return chunk.timestamp[1];
}

function normalizeWord(s) {
  return s.toLowerCase().replace(/[^a-z0-9\u00C0-\u024F]/g, "");
}

function tokenize(text) {
  return text.trim().split(" ").filter(function (s) {
              return s.trim() !== "";
            });
}

function computeLCS(oldTokens, newTokens) {
  var m = oldTokens.length;
  var n = newTokens.length;
  if (m === 0 || n === 0) {
    return [];
  }
  var oldNormalized = oldTokens.map(normalizeWord);
  var newNormalized = newTokens.map(normalizeWord);
  var dp = Core__Array.fromInitializer(m + 1 | 0, (function (param) {
          return Core__Array.make(n + 1 | 0, 0);
        }));
  for(var i = 1; i <= m; ++i){
    for(var j = 1; j <= n; ++j){
      var dpRow = dp[i];
      var dpPrevRow = dp[i - 1 | 0];
      var oldNorm = oldNormalized[i - 1 | 0];
      var newNorm = newNormalized[j - 1 | 0];
      if (oldNorm !== "" && newNorm !== "" && oldNorm === newNorm) {
        dpRow[j] = dpPrevRow[j - 1 | 0] + 1 | 0;
      } else {
        var fromTop = dpPrevRow[j];
        var fromLeft = dpRow[j - 1 | 0];
        dpRow[j] = fromTop > fromLeft ? fromTop : fromLeft;
      }
    }
  }
  var result = [];
  var i$1 = m;
  var j$1 = n;
  while(i$1 > 0 && j$1 > 0) {
    var dpRow$1 = dp[i$1];
    var dpPrevRow$1 = dp[i$1 - 1 | 0];
    var oldNorm$1 = oldNormalized[i$1 - 1 | 0];
    var newNorm$1 = newNormalized[j$1 - 1 | 0];
    if (oldNorm$1 !== "" && newNorm$1 !== "" && oldNorm$1 === newNorm$1) {
      result.push([
            i$1 - 1 | 0,
            j$1 - 1 | 0
          ]);
      i$1 = i$1 - 1 | 0;
      j$1 = j$1 - 1 | 0;
    } else if (dpPrevRow$1[j$1] > dpRow$1[j$1 - 1 | 0]) {
      i$1 = i$1 - 1 | 0;
    } else {
      j$1 = j$1 - 1 | 0;
    }
  };
  return result.toReversed();
}

function interpolateTimestamps(prevEnd, nextStart, count) {
  if (count <= 0) {
    return [];
  }
  var gap = nextStart - prevEnd;
  var segmentDuration = gap > 0.0 ? gap / count : 0.0;
  return Core__Array.fromInitializer(count, (function (i) {
                var startTime = prevEnd + i * segmentDuration;
                var endTime = prevEnd + (i + 1 | 0) * segmentDuration;
                return [
                        startTime,
                        endTime
                      ];
              }));
}

function applyTextEdit(oldWords, newText) {
  var newTokens = tokenize(newText);
  var oldCount = oldWords.length;
  var newCount = newTokens.length;
  if (newCount === 0) {
    return [];
  }
  if (oldCount === 0) {
    return [{
              text: newText,
              timestamp: [
                0.0,
                null
              ]
            }];
  }
  var oldTokens = oldWords.map(function (w) {
        return w.text;
      });
  var matches = computeLCS(oldTokens, newTokens);
  if (matches.length === 0) {
    var firstStart = oldWords[0].timestamp[0];
    var lastEnd = oldWords[oldCount - 1 | 0].timestamp[1];
    return [{
              text: newText,
              timestamp: [
                firstStart,
                lastEnd
              ]
            }];
  }
  var result = [];
  var numMatches = matches.length;
  var match = matches[0];
  var firstMatchNewIdx = match[1];
  var firstMatchOldIdx = match[0];
  var match$1 = matches[numMatches - 1 | 0];
  var lastMatchOldIdx = match$1[0];
  var hasOldWordsBefore = firstMatchOldIdx > 0;
  var hasOldWordsAfter = lastMatchOldIdx < (oldCount - 1 | 0);
  if (firstMatchNewIdx > 0) {
    var newTokensBefore = newTokens.slice(0, firstMatchNewIdx);
    if (hasOldWordsBefore) {
      var oldWordsBefore = oldWords.slice(0, firstMatchOldIdx);
      var newCountBefore = newTokensBefore.length;
      var oldCountBefore = oldWordsBefore.length;
      var assignCount = newCountBefore < oldCountBefore ? newCountBefore : oldCountBefore;
      for(var i = 0; i < assignCount; ++i){
        var token = newTokensBefore[i];
        var ts = oldWordsBefore[i].timestamp;
        result.push({
              text: token,
              timestamp: ts
            });
      }
    }
    
  }
  var startMergeText = firstMatchNewIdx > 0 && !hasOldWordsBefore ? newTokens.slice(0, firstMatchNewIdx).join(" ") : (
      firstMatchNewIdx > 0 && hasOldWordsBefore && firstMatchNewIdx > firstMatchOldIdx ? newTokens.slice(firstMatchOldIdx, firstMatchNewIdx).join(" ") : ""
    );
  matches.forEach(function (match_, matchIdx) {
        var newIdx = match_[1];
        var oldIdx = match_[0];
        var betweenMergeText = "";
        if (matchIdx > 0) {
          var match = matches[matchIdx - 1 | 0];
          var newTokensBetween = newTokens.slice(match[1] + 1 | 0, newIdx);
          var oldWordsBetween = oldWords.slice(match[0] + 1 | 0, oldIdx);
          var newCountBetween = newTokensBetween.length;
          var oldCountBetween = oldWordsBetween.length;
          if (newCountBetween > 0) {
            if (oldCountBetween > 0) {
              var assignCount = newCountBetween < oldCountBetween ? newCountBetween : oldCountBetween;
              for(var i = 0; i < assignCount; ++i){
                var token = newTokensBetween[i];
                var ts = oldWordsBetween[i].timestamp;
                result.push({
                      text: token,
                      timestamp: ts
                    });
              }
              if (newCountBetween > oldCountBetween) {
                var remainingNewTokens = newTokensBetween.slice(assignCount);
                betweenMergeText = remainingNewTokens.join(" ");
              }
              
            } else {
              betweenMergeText = newTokensBetween.join(" ");
            }
          }
          
        }
        var originalTs = oldWords[oldIdx].timestamp;
        var matchedToken = newTokens[newIdx];
        var finalText = matchIdx === 0 && startMergeText !== "" ? (
            betweenMergeText !== "" ? startMergeText + " " + betweenMergeText + " " + matchedToken : startMergeText + " " + matchedToken
          ) : (
            betweenMergeText !== "" ? betweenMergeText + " " + matchedToken : matchedToken
          );
        result.push({
              text: finalText,
              timestamp: originalTs
            });
      });
  var newTokensAfterStart = match$1[1] + 1 | 0;
  if (newTokensAfterStart < newCount) {
    var newTokensAfter = newTokens.slice(newTokensAfterStart);
    var newCountAfter = newTokensAfter.length;
    if (hasOldWordsAfter) {
      var oldWordsAfter = oldWords.slice(lastMatchOldIdx + 1 | 0);
      var oldCountAfter = oldWordsAfter.length;
      var assignCount$1 = newCountAfter < oldCountAfter ? newCountAfter : oldCountAfter;
      for(var i$1 = 0; i$1 < assignCount$1; ++i$1){
        var token$1 = newTokensAfter[i$1];
        var ts$1 = oldWordsAfter[i$1].timestamp;
        result.push({
              text: token$1,
              timestamp: ts$1
            });
      }
      if (newCountAfter > oldCountAfter) {
        var excessTokens = newTokensAfter.slice(assignCount$1);
        var excessText = excessTokens.join(" ");
        var lastIdx = result.length - 1 | 0;
        var lastChunk = result[lastIdx];
        result[lastIdx] = {
          text: lastChunk.text + " " + excessText,
          timestamp: lastChunk.timestamp
        };
      }
      
    } else {
      var lastIdx$1 = result.length - 1 | 0;
      var lastChunk$1 = result[lastIdx$1];
      result[lastIdx$1] = {
        text: lastChunk$1.text + " " + newTokensAfter.join(" "),
        timestamp: lastChunk$1.timestamp
      };
    }
  }
  return result;
}

export {
  start ,
  end_ ,
  normalizeWord ,
  tokenize ,
  computeLCS ,
  interpolateTimestamps ,
  applyTextEdit ,
}
/* No side effect */
