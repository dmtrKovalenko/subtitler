// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "./Utils.res.mjs";
import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Subtitles from "./screens/editor/Subtitles.res.mjs";
import * as Dom_storage from "rescript/lib/es6/dom_storage.js";
import * as UseObservable from "./hooks/useObservable.res.mjs";

var currentFps = {
  contents: undefined
};

var validateVolume = Utils.$$Math.minMax(0, 100);

function MakePlayer(Ctx) {
  var savedValue = Dom_storage.getItem("subtitles_volume", localStorage);
  var volume = savedValue !== undefined ? Belt_Int.fromString(savedValue) : 60;
  var initial_currentPlayingCue = Subtitles.lookupCurrentCue(Ctx.subtitlesRef.current, 0);
  var initial = {
    frame: 0,
    startPlayingFrame: 0,
    playState: "Paused",
    currentPlayingCue: initial_currentPlayingCue,
    volume: volume
  };
  var PlayerState = {
    volume: volume,
    initial: initial
  };
  var renderFrame = function () {
    var el = Ctx.dom.canvasRef.current;
    if (el == null) {
      return ;
    }
    var ctx = el.getContext("2d");
    ctx.drawImage(Ctx.dom.videoElement, 0, 0, Ctx.videoMeta.width, Ctx.videoMeta.height);
  };
  var include = UseObservable.Pubsub({
        initial: initial
      });
  var get = include.get;
  var set = include.set;
  var reducer = function (action) {
    var state = get();
    if (typeof action !== "object") {
      switch (action) {
        case "AllowPlay" :
            return {
                    frame: state.frame,
                    startPlayingFrame: state.startPlayingFrame,
                    playState: "WaitingForAction",
                    currentPlayingCue: state.currentPlayingCue,
                    volume: state.volume
                  };
        case "Play" :
            if (state.frame <= 0 || state.frame >= Ctx.videoMeta.duration) {
              return {
                      frame: 0,
                      startPlayingFrame: state.startPlayingFrame,
                      playState: "Playing",
                      currentPlayingCue: state.currentPlayingCue,
                      volume: state.volume
                    };
            } else {
              return {
                      frame: state.frame,
                      startPlayingFrame: state.frame,
                      playState: "Playing",
                      currentPlayingCue: state.currentPlayingCue,
                      volume: state.volume
                    };
            }
        case "Pause" :
            return {
                    frame: state.frame,
                    startPlayingFrame: state.startPlayingFrame,
                    playState: "Paused",
                    currentPlayingCue: state.currentPlayingCue,
                    volume: state.volume
                  };
        
      }
    } else {
      switch (action.TAG) {
        case "Seek" :
        case "NewFrame" :
            break;
        case "SetVolume" :
            return {
                    frame: state.frame,
                    startPlayingFrame: state.startPlayingFrame,
                    playState: state.playState,
                    currentPlayingCue: state.currentPlayingCue,
                    volume: action._0
                  };
        
      }
    }
    var frame = action._0;
    if (frame >= Ctx.videoMeta.duration || frame < 0) {
      return {
              frame: 0,
              startPlayingFrame: frame,
              playState: "Paused",
              currentPlayingCue: state.currentPlayingCue,
              volume: state.volume
            };
    }
    if (typeof action === "object") {
      if (action.TAG === "Seek") {
        var frame$1 = action._0;
        return {
                frame: frame$1,
                startPlayingFrame: frame$1,
                playState: state.playState,
                currentPlayingCue: Subtitles.lookupCurrentCue(Ctx.subtitlesRef.current, frame$1),
                volume: state.volume
              };
      }
      var frame$2 = action._0;
      return {
              frame: frame$2,
              startPlayingFrame: state.startPlayingFrame,
              playState: state.playState,
              currentPlayingCue: Subtitles.getOrLookupCurrentCue(frame$2, Ctx.subtitlesRef.current, state.currentPlayingCue),
              volume: state.volume
            };
    }
    
  };
  var onFrame = function (dispatch) {
    renderFrame();
    var seconds = Ctx.dom.videoElement.currentTime;
    if (get().playState === "Playing") {
      dispatch({
            TAG: "NewFrame",
            _0: seconds
          });
    }
    if (!Ctx.dom.videoElement.paused) {
      requestAnimationFrame(function (param) {
            onFrame(dispatch);
          });
      return ;
    }
    
  };
  var sideEffect = function (action, dispatch) {
    var startPlaying = function (currentTs) {
      Ctx.dom.videoElement.play();
      Ctx.dom.videoElement.currentTime = currentTs;
      requestAnimationFrame(function (param) {
            onFrame(dispatch);
          });
    };
    if (typeof action !== "object") {
      switch (action) {
        case "AllowPlay" :
            return ;
        case "Play" :
            if (get().playState !== "Playing") {
              return startPlaying(get().frame);
            } else {
              return ;
            }
        case "Pause" :
            Ctx.dom.videoElement.pause();
            return ;
        
      }
    } else {
      switch (action.TAG) {
        case "Seek" :
            return startPlaying(action._0);
        case "NewFrame" :
            if (get().playState !== "Playing") {
              Ctx.dom.videoElement.currentTime = action._0;
              return renderFrame();
            } else {
              return ;
            }
        case "SetVolume" :
            var volume = action._0;
            Ctx.dom.videoElement.volume = volume / 100;
            return Dom_storage.setItem("subtitles_volume", volume.toString(), localStorage);
        
      }
    }
  };
  var dispatch = function (action) {
    sideEffect(action, dispatch);
    set(reducer(action));
  };
  return {
          PlayerState: PlayerState,
          renderFrame: renderFrame,
          mutableState: include.mutableState,
          listeners: include.listeners,
          get: get,
          set: set,
          nextId: include.nextId,
          subscribe: include.subscribe,
          useObservable: include.useObservable,
          reducer: reducer,
          onFrame: onFrame,
          sideEffect: sideEffect,
          dispatch: dispatch
        };
}

var min_volume = 0;

var max_volume = 100;

export {
  currentFps ,
  min_volume ,
  max_volume ,
  validateVolume ,
  MakePlayer ,
}
/* validateVolume Not a pure module */
