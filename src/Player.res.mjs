// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "./Utils.res.mjs";
import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Subtitles from "./screens/editor/Subtitles.res.mjs";
import * as Dom_storage from "rescript/lib/es6/dom_storage.js";
import * as Core__Option from "@rescript/core/src/Core__Option.res.mjs";
import * as UseObservable from "./hooks/useObservable.res.mjs";

var currentFps = {
  contents: undefined
};

var validateVolume = Utils.$$Math.minMax(0, 100);

function MakePlayer(Ctx) {
  var savedValue = Dom_storage.getItem("subtitles_volume", localStorage);
  var volume = savedValue !== undefined ? Belt_Int.fromString(savedValue) : 60;
  var initial_currentPlayingCue = Subtitles.lookupCurrentCue(Ctx.subtitlesRef.current, 0);
  var initial = {
    ts: 0,
    startPlayingTs: 0,
    playState: "Idle",
    currentPlayingCue: initial_currentPlayingCue,
    volume: volume
  };
  var PlayerState = {
    volume: volume,
    initial: initial
  };
  var include = UseObservable.Pubsub({
        initial: initial
      });
  var get = include.get;
  var set = include.set;
  var renderFrame = function () {
    var match = Ctx.dom.canvasRef.current;
    var match$1 = get().playState;
    if (match == null) {
      return ;
    }
    if (match$1 === "StoppedForRender") {
      return ;
    }
    var ctx = match.getContext("2d");
    ctx.drawImage(Ctx.dom.videoElement, 0, 0, Ctx.videoMeta.width, Ctx.videoMeta.height);
  };
  var reducer = function (action) {
    var state = get();
    var exit = 0;
    if (typeof action !== "object") {
      if (action === "AbortRender") {
        return {
                ts: state.ts,
                startPlayingTs: state.startPlayingTs,
                playState: "Paused",
                currentPlayingCue: state.currentPlayingCue,
                volume: state.volume
              };
      }
      exit = 1;
    } else {
      exit = 1;
    }
    if (exit === 1) {
      if (state.playState === "StoppedForRender") {
        return state;
      }
      var exit$1 = 0;
      if (typeof action !== "object") {
        switch (action) {
          case "Play" :
              if (state.ts <= 0 || state.ts >= Ctx.videoMeta.duration) {
                return {
                        ts: 0,
                        startPlayingTs: state.startPlayingTs,
                        playState: "Playing",
                        currentPlayingCue: state.currentPlayingCue,
                        volume: state.volume
                      };
              } else {
                return {
                        ts: state.ts,
                        startPlayingTs: state.ts,
                        playState: "Playing",
                        currentPlayingCue: state.currentPlayingCue,
                        volume: state.volume
                      };
              }
          case "Pause" :
              return {
                      ts: state.ts,
                      startPlayingTs: state.startPlayingTs,
                      playState: "Paused",
                      currentPlayingCue: state.currentPlayingCue,
                      volume: state.volume
                    };
          case "StopForRender" :
              return {
                      ts: state.ts,
                      startPlayingTs: state.startPlayingTs,
                      playState: "StoppedForRender",
                      currentPlayingCue: state.currentPlayingCue,
                      volume: state.volume
                    };
          case "UpdateCurrentCue" :
              var currentPlayingCue = Subtitles.lookupCurrentCue(Ctx.subtitlesRef.current, state.ts);
              return {
                      ts: state.ts,
                      startPlayingTs: state.startPlayingTs,
                      playState: state.playState,
                      currentPlayingCue: currentPlayingCue,
                      volume: state.volume
                    };
          
        }
      } else {
        switch (action.TAG) {
          case "Seek" :
          case "NewFrame" :
              exit$1 = 2;
              break;
          case "SetVolume" :
              return {
                      ts: state.ts,
                      startPlayingTs: state.startPlayingTs,
                      playState: state.playState,
                      currentPlayingCue: state.currentPlayingCue,
                      volume: action._0
                    };
          
        }
      }
      if (exit$1 === 2) {
        var ts = action._0;
        if (ts >= Ctx.videoMeta.duration || ts < 0) {
          return {
                  ts: 0,
                  startPlayingTs: ts,
                  playState: "Paused",
                  currentPlayingCue: state.currentPlayingCue,
                  volume: state.volume
                };
        }
        if (typeof action === "object") {
          if (action.TAG === "Seek") {
            var ts$1 = action._0;
            return {
                    ts: ts$1,
                    startPlayingTs: ts$1,
                    playState: state.playState === "Idle" ? "Paused" : state.playState,
                    currentPlayingCue: Subtitles.lookupCurrentCue(Ctx.subtitlesRef.current, ts$1),
                    volume: state.volume
                  };
          }
          var ts$2 = action._0;
          return {
                  ts: ts$2,
                  startPlayingTs: state.startPlayingTs,
                  playState: state.playState === "Idle" ? "Paused" : state.playState,
                  currentPlayingCue: Subtitles.getOrLookupCurrentCue(ts$2, Ctx.subtitlesRef.current, state.currentPlayingCue),
                  volume: state.volume
                };
        }
        
      }
      
    }
    
  };
  var onFrame = function (dispatch) {
    renderFrame();
    var seconds = Ctx.dom.videoElement.currentTime;
    if (get().playState === "Playing") {
      dispatch({
            TAG: "NewFrame",
            _0: seconds
          });
    }
    if (!Ctx.dom.videoElement.paused) {
      requestAnimationFrame(function (param) {
            onFrame(dispatch);
          });
      return ;
    }
    
  };
  var sideEffect = function (action, dispatch) {
    if (get().playState === "StoppedForRender") {
      return ;
    }
    if (typeof action !== "object") {
      switch (action) {
        case "Play" :
            if (get().playState !== "Playing") {
              var currentTs = get().ts;
              Core__Option.forEach(get().volume, (function (volume) {
                      Ctx.dom.videoElement.volume = volume / 100;
                    }));
              Ctx.dom.videoElement.play();
              Ctx.dom.videoElement.currentTime = currentTs;
              requestAnimationFrame(function (param) {
                    onFrame(dispatch);
                  });
              return ;
            } else {
              return ;
            }
        case "Pause" :
        case "StopForRender" :
            Ctx.dom.videoElement.pause();
            return ;
        case "AbortRender" :
        case "UpdateCurrentCue" :
            return ;
        
      }
    } else {
      switch (action.TAG) {
        case "Seek" :
            Ctx.dom.videoElement.currentTime = action._0;
            return renderFrame();
        case "NewFrame" :
            if (get().playState !== "Playing") {
              Ctx.dom.videoElement.currentTime = action._0;
              return renderFrame();
            } else {
              return ;
            }
        case "SetVolume" :
            var volume = action._0;
            Ctx.dom.videoElement.volume = volume / 100;
            return Dom_storage.setItem("subtitles_volume", volume.toString(), localStorage);
        
      }
    }
  };
  var dispatch = function (action) {
    sideEffect(action, dispatch);
    set(reducer(action));
  };
  return {
          PlayerState: PlayerState,
          mutableState: include.mutableState,
          listeners: include.listeners,
          get: get,
          set: set,
          nextId: include.nextId,
          subscribe: include.subscribe,
          useObservable: include.useObservable,
          useObservableSelector: include.useObservableSelector,
          renderFrame: renderFrame,
          reducer: reducer,
          onFrame: onFrame,
          sideEffect: sideEffect,
          dispatch: dispatch
        };
}

var min_volume = 0;

var max_volume = 100;

export {
  currentFps ,
  min_volume ,
  max_volume ,
  validateVolume ,
  MakePlayer ,
}
/* validateVolume Not a pure module */
