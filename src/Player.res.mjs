// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Utils from "./Utils.res.mjs";
import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Dom_storage from "rescript/lib/es6/dom_storage.js";
import * as UseObservable from "./hooks/useObservable.res.mjs";

var currentFps = {
  contents: undefined
};

var validateVolume = Utils.$$Math.minMax(0, 100);

function MakePlayer(Ctx) {
  var savedValue = Dom_storage.getItem("subtitles_volume", localStorage);
  var volume = savedValue !== undefined ? Belt_Int.fromString(savedValue) : 60;
  var initial = {
    frame: 0,
    startPlayingFrame: 0,
    playState: "Paused",
    volume: volume
  };
  var PlayerState = {
    volume: volume,
    initial: initial
  };
  var renderFrame = function () {
    var el = Ctx.canvasRef.current;
    if (el == null) {
      return ;
    }
    var ctx = el.getContext("2d");
    Ctx.renderVideoFrame(ctx, undefined, undefined, undefined, undefined);
  };
  var include = UseObservable.Pubsub({
        initial: initial
      });
  var get = include.get;
  var set = include.set;
  var reducer = function (action) {
    var state = get();
    if (typeof action !== "object") {
      switch (action) {
        case "AllowPlay" :
            return {
                    frame: state.frame,
                    startPlayingFrame: state.startPlayingFrame,
                    playState: "WaitingForAction",
                    volume: state.volume
                  };
        case "Play" :
            if (state.frame <= 0 || state.frame >= Ctx.videoMeta.duration) {
              return {
                      frame: 0,
                      startPlayingFrame: state.startPlayingFrame,
                      playState: "Playing",
                      volume: state.volume
                    };
            } else {
              return {
                      frame: state.frame,
                      startPlayingFrame: state.frame,
                      playState: "Playing",
                      volume: state.volume
                    };
            }
        case "Pause" :
            return {
                    frame: state.frame,
                    startPlayingFrame: state.startPlayingFrame,
                    playState: "Paused",
                    volume: state.volume
                  };
        
      }
    } else {
      switch (action.TAG) {
        case "Seek" :
        case "NewFrame" :
            break;
        case "SetVolume" :
            return {
                    frame: state.frame,
                    startPlayingFrame: state.startPlayingFrame,
                    playState: state.playState,
                    volume: action._0
                  };
        
      }
    }
    var frame = action._0;
    if (frame >= Ctx.videoMeta.duration || frame < 0) {
      return {
              frame: 0,
              startPlayingFrame: frame,
              playState: "Paused",
              volume: state.volume
            };
    }
    var tmp;
    tmp = typeof action !== "object" || action.TAG !== "Seek" ? state.startPlayingFrame : action._0;
    return {
            frame: action._0,
            startPlayingFrame: tmp,
            playState: state.playState,
            volume: state.volume
          };
  };
  var onFrame = function (dispatch) {
    renderFrame();
    var seconds = Ctx.videoElement.currentTime;
    if (get().playState === "Playing") {
      dispatch({
            TAG: "NewFrame",
            _0: seconds
          });
    }
    if (!Ctx.videoElement.paused) {
      requestAnimationFrame(function (param) {
            onFrame(dispatch);
          });
      return ;
    }
    
  };
  var sideEffect = function (action, dispatch) {
    var startPlaying = function (currentTs) {
      Ctx.videoElement.play();
      Ctx.videoElement.currentTime = currentTs;
      requestAnimationFrame(function (param) {
            onFrame(dispatch);
          });
    };
    if (typeof action !== "object") {
      switch (action) {
        case "AllowPlay" :
            return ;
        case "Play" :
            if (get().playState !== "Playing") {
              return startPlaying(get().frame);
            } else {
              return ;
            }
        case "Pause" :
            Ctx.videoElement.pause();
            return ;
        
      }
    } else {
      switch (action.TAG) {
        case "Seek" :
            return startPlaying(action._0);
        case "NewFrame" :
            if (get().playState !== "Playing") {
              Ctx.videoElement.currentTime = action._0;
              return renderFrame();
            } else {
              return ;
            }
        case "SetVolume" :
            console.log("set volume");
            return Dom_storage.setItem("subtitles_volume", action._0.toString(), localStorage);
        
      }
    }
  };
  var dispatch = function (action) {
    sideEffect(action, dispatch);
    set(reducer(action));
  };
  return {
          PlayerState: PlayerState,
          renderFrame: renderFrame,
          mutableState: include.mutableState,
          listeners: include.listeners,
          get: get,
          set: set,
          nextId: include.nextId,
          subscribe: include.subscribe,
          useObservable: include.useObservable,
          reducer: reducer,
          onFrame: onFrame,
          sideEffect: sideEffect,
          dispatch: dispatch
        };
}

var min_volume = 0;

var max_volume = 100;

export {
  currentFps ,
  min_volume ,
  max_volume ,
  validateVolume ,
  MakePlayer ,
}
/* validateVolume Not a pure module */
